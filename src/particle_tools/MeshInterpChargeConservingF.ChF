
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c  Charge-conserving deposit for particle current density using a combination
c  of NGP and CIC interpolation with cell crossings included
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine cc0_1d_deposit_current(
     &                       CHF_FRA1[rhoVx],
     &                       CHF_FRA1[rhoVy],
     &                       CHF_FRA1[rhoVz],
     &                       CHF_CONST_REALVECT[left_edge],
     &                       CHF_CONST_REALVECT[dx],
     &                       CHF_CONST_REALVECT[xpold],
     &                       CHF_CONST_REALVECT[xphalf],
     &                       CHF_CONST_REAL[vpx], 
     &                       CHF_CONST_REAL[vpy], 
     &                       CHF_CONST_REAL[vpz], 
     &                       CHF_CONST_REAL[qp]) 

      integer index_stag(0:CH_SPACEDIM - 1)
      integer index_stag_old(0:CH_SPACEDIM - 1), index_stag_new(0:CH_SPACEDIM - 1)
      integer cell_crossings(0:CH_SPACEDIM - 1), idir, num_segments
      REAL_T CHF_DDECL[l0;l1;l2], CHF_DDECL[w0;w1;w2]
      REAL_T dXp(0:CH_SPACEDIM - 1), xpold0(0:CH_SPACEDIM - 1)
      REAL_T dXp_sub(0:CH_SPACEDIM - 1), xpnew0(0:CH_SPACEDIM - 1) 
      REAL_T xpnew(0:CH_SPACEDIM - 1), Xcell(0:CH_SPACEDIM - 1)
      REAL_T volume, rhop, weight, seg_factor
      integer nn, sign(0:CH_SPACEDIM - 1), i0
      integer ii, jj, kk, ii_next, jj_next, kk_next 

c     compute the cell volume and particle density on the grid
      volume = CHF_DTERM[dx(0);*dx(1);*dx(2)]
      rhop = qp / volume

c     compute the new particle position
      do idir = 0, CH_SPACEDIM - 1
        xpnew(idir) = two*xphalf(idir) - xpold(idir)
        dXp(idir) = xpnew(idir) - xpold(idir)
        sign(idir) = 1
      enddo
     
      i0 = 0

c     compute the index of the left most cell/edge that contains this particle cloud
      num_segments = 1
      do idir = 0, CH_SPACEDIM - 1
        index_stag_old(idir) = floor((xpold(idir) - left_edge(idir)) / dx(idir))
        index_stag_new(idir) = floor((xpnew(idir) - left_edge(idir)) / dx(idir))
        if(index_stag_new(idir)<index_stag_old(idir)) then
          sign(idir) = -1
        endif
        cell_crossings(idir) = ABS(index_stag_new(idir) - index_stag_old(idir))
        num_segments = num_segments + cell_crossings(idir)
      enddo

c     calculate the initial Xcell in each direction
      do idir = 0, CH_SPACEDIM -1
        Xcell(idir) = left_edge(idir) + (index_stag_old(idir) + half*(1-sign(idir)))*dx(idir)
      enddo

      xpold0 = xpold
      CHF_DTERM[ii_next=index_stag_old(0); 
                jj_next=index_stag_old(1); 
                kk_next=index_stag_old(2)]

      do nn=0, num_segments-1

        CHF_DTERM[ii=ii_next; 
                  jj=jj_next; 
                  kk=kk_next]

        if(nn==num_segments-1) then
          xpnew0 = xpnew
          dXp_sub = xpnew0 - xpold0
        else
          ii_next = ii + sign(i0)
          Xcell(i0) = Xcell(i0) + sign(i0)*dx(i0)
          xpnew0(i0) = Xcell(i0)
          dXp_sub(i0) = xpnew0(i0) - xpold0(i0)
        endif

c     deposit the particle x-current to the grid
        if(num_segments>1) then
          seg_factor = dXp_sub(i0)/dXp(i0)
        else
          seg_factor = 1.d0
        endif

        weight = seg_factor
        rhoVx(CHF_IX[ii; jj; kk]) = 
     &  rhoVx(CHF_IX[ii; jj; kk]) + vpx * rhop * weight
        
c     update xpold
        xpold0 = xpnew0
            
      enddo

c
c     deposit the particle y an z current to the grid
c

      do idir = 0, CH_SPACEDIM - 1
        index_stag(idir) = floor((xphalf(idir) - left_edge(idir)) / dx(idir))
      enddo

      CHF_DTERM[
      do ii = index_stag(0), index_stag(0) + 1
        l0 = ii*dx(0) - xphalf(0) + left_edge(0)
        w0 = 1.d0 - abs(l0/dx(0));
        do jj = index_stag(1), index_stag(1) + 1
          l1 = jj*dx(1) - xphalf(1) + left_edge(1)
          w1 = 1.d0;
          do kk = 1, 2
            l2 = 0
            w2 = 1.d0 ]

            weight = CHF_DTERM[w0; *w1; *w2]
            rhoVy(CHF_IX[ii; jj; kk]) = 
     &      rhoVy(CHF_IX[ii; jj; kk]) + vpy * rhop * weight

            rhoVz(CHF_IX[ii; jj; kk]) = 
     &      rhoVz(CHF_IX[ii; jj; kk]) + vpz * rhop * weight

      CHF_DTERM[
          enddo;
        enddo;
      enddo]

      end

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c  Charge-conserving deposit for particle current density using a combination
c  of NGP and CIC interpolation with cell crossings included
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine cc0_2d_deposit_current(
     &                       CHF_FRA1[rhoVx],
     &                       CHF_FRA1[rhoVy],
     &                       CHF_FRA1[rhoVz],
     &                       CHF_CONST_REALVECT[left_edge],
     &                       CHF_CONST_REALVECT[dx],
     &                       CHF_CONST_REALVECT[xpold],
     &                       CHF_CONST_REALVECT[xphalf],
     &                       CHF_CONST_REAL[vpx], 
     &                       CHF_CONST_REAL[vpy], 
     &                       CHF_CONST_REAL[vpz], 
     &                       CHF_CONST_REAL[qp]) 

      integer index_stag(0:CH_SPACEDIM - 1)
      integer index_stag_old(0:CH_SPACEDIM - 1), index_stag_new(0:CH_SPACEDIM - 1)
      integer cell_crossings(0:CH_SPACEDIM - 1), idir, num_segments
      REAL_T CHF_DDECL[l0;l1;l2], CHF_DDECL[w0;w1;w2]
      REAL_T dXp(0:CH_SPACEDIM - 1), xpold0(0:CH_SPACEDIM - 1)
      REAL_T dXp_sub(0:CH_SPACEDIM - 1), xpnew0(0:CH_SPACEDIM - 1) 
      REAL_T xpnew(0:CH_SPACEDIM - 1), Xcell(0:CH_SPACEDIM - 1)
      REAL_T volume, rhop, weight, slope, slope_inv, dXp_sub02
      integer nn, sign(0:CH_SPACEDIM - 1), i0, i1
      integer ii, jj, kk, ii_next, jj_next, kk_next 

c     compute the cell volume and particle density on the grid
      volume = CHF_DTERM[dx(0);*dx(1);*dx(2)]
      rhop = qp / volume

c     compute the new particle position
      do idir = 0, CH_SPACEDIM - 1
        xpnew(idir) = two*xphalf(idir) - xpold(idir)
        dXp(idir) = xpnew(idir) - xpold(idir)
        sign(idir) = 1
      enddo
     
c     compute slopes assuming 2D
      i0 = 0
      i1 = CH_SPACEDIM-1
      slope = dXp(i1)/dXp(i0)
      slope_inv = 1/slope

c     compute the index of the left most cell/edge that contains this particle cloud
      num_segments = 1
      do idir = 0, CH_SPACEDIM - 1
        index_stag_old(idir) = floor((xpold(idir) - left_edge(idir)) / dx(idir))
        index_stag_new(idir) = floor((xpnew(idir) - left_edge(idir)) / dx(idir))
        if(index_stag_new(idir)<index_stag_old(idir)) then
          sign(idir) = -1
        endif
        cell_crossings(idir) = ABS(index_stag_new(idir) - index_stag_old(idir))
        num_segments = num_segments + cell_crossings(idir)
      enddo

c     calculate the initial Xcell in each direction
      do idir = 0, CH_SPACEDIM -1
        Xcell(idir) = left_edge(idir) + (index_stag_old(idir) + half*(1-sign(idir)))*dx(idir)
      enddo

      xpold0 = xpold
      CHF_DTERM[ii_next=index_stag_old(0); 
                jj_next=index_stag_old(1); 
                kk_next=index_stag_old(2)]

      do nn=0, num_segments-1

        CHF_DTERM[ii=ii_next; 
                  jj=jj_next; 
                  kk=kk_next]

        if(nn==num_segments-1) then
          xpnew0 = xpnew
          dXp_sub = xpnew0 - xpold0
        else if(cell_crossings(i0)==0) then
          jj_next = jj + sign(i1)
          Xcell(i1) = Xcell(i1) + sign(i1)*dx(i1)
          xpnew0(i1) = Xcell(i1)
          dXp_sub(i1) = xpnew0(i1) - xpold0(i1)
          dXp_sub(i0) = slope_inv*dXp_sub(i1)
          xpnew0(i0) = xpold0(i0) + dXp_sub(i0)
        else if(cell_crossings(i1)==0) then
          ii_next = ii + sign(i0)
          Xcell(i0) = Xcell(i0) + sign(i0)*dx(i0)
          xpnew0(i0) = Xcell(i0)
          dXp_sub(i0) = xpnew0(i0) - xpold0(i0)
          dXp_sub(i1) = slope*dXp_sub(i0)
          xpnew0(i1) = xpold0(i1) + dXp_sub(i1)
        else
          xpnew0(i0) = Xcell(i0) + sign(i0)*dx(i0)
          xpnew0(i1) = Xcell(i1) + sign(i1)*dx(i1)
          dXp_sub(i0) = xpnew0(i0) - xpold0(i0)
          dXp_sub(i1) = xpnew0(i1) - xpold0(i1)
          dXp_sub02 = slope_inv*dXp_sub(i1)

          if(abs(dXp_sub(i0))<abs(dXp_sub02)) then
            dXp_sub(i1) = slope*dXp_sub(i0)
            xpnew0(i1) = xpold0(i1) + dXp_sub(i1)
            Xcell(i0) = xpnew0(i0)
            ii_next = ii + sign(i0)
            cell_crossings(i0) = cell_crossings(i0) - 1
          else
            dXp_sub(i0) = slope_inv*dXp_sub(i1)
            xpnew0(i0) = xpold0(i0) + dXp_sub(i0)
            Xcell(i1) = xpnew0(i1)
            jj_next = jj + sign(i1)
            cell_crossings(i1) = cell_crossings(i1) - 1
          endif

        endif

        CHF_DTERM[l0 = half*(xpold0(0)+xpnew0(0)) - (left_edge(0) + ii*dx(0));
                  l1 = half*(xpold0(1)+xpnew0(1)) - (left_edge(1) + jj*dx(1));
                  l2 = half*(xpold0(2)+xpnew0(2)) - (left_edge(2) + kk*dx(2))]

c     deposit the particle x-current to the grid
        if(num_segments>1) then
          CHF_DTERM[w0 = dXp_sub(i0)/dXp(i0);
                    w1 = 1.d0 - l1/dx(1);
                    w2 = 0.0]
        else
          CHF_DTERM[w0 = 1.d0;
                    w1 = 1.d0 - l1/dx(1);
                    w2 = 0.0]
        endif

        weight = CHF_DTERM[w0; *w1; *w2]
        rhoVx(CHF_IX[ii; jj; kk]) = 
     &  rhoVx(CHF_IX[ii; jj; kk]) + vpx * rhop * weight
        
        weight = CHF_DTERM[w0; *(1.d0-w1); *w2]
        rhoVx(CHF_IX[ii; jj+1; kk]) = 
     &  rhoVx(CHF_IX[ii; jj+1; kk]) + vpx * rhop * weight

c     deposit the particle y-current to the grid
        if(num_segments>1) then
          CHF_DTERM[w0 = 1.d0 - l0/dx(0);
                    w1 = dXp_sub(i1)/dXp(i1);
                    w2 = 1.d0]
        else
          CHF_DTERM[w0 = 1.d0 - l0/dx(0);
                    w1 = 1.d0;
                    w2 = 1.d0]
        endif

        weight = CHF_DTERM[w0; *w1; *w2]
        rhoVy(CHF_IX[ii; jj; kk]) = 
     &  rhoVy(CHF_IX[ii; jj; kk]) + vpy * rhop * weight
        
        weight = CHF_DTERM[(1.d0-w0); *w1; *w2]
        rhoVy(CHF_IX[ii+1; jj; kk]) = 
     &  rhoVy(CHF_IX[ii+1; jj; kk]) + vpy * rhop * weight

c     update xpold
        xpold0 = xpnew0
            
      enddo

c
c     deposit the particle z-current to the grid
c

      do idir = 0, CH_SPACEDIM - 1
        index_stag(idir) = floor((xphalf(idir) - left_edge(idir)) / dx(idir))
      enddo

      CHF_DTERM[
      do ii = index_stag(0), index_stag(0) + 1
        l0 = ii*dx(0) - xphalf(0) + left_edge(0)
        w0 = 1.d0 - abs(l0/dx(0));
        do jj = index_stag(1), index_stag(1) + 1
          l1 = jj*dx(1) - xphalf(1) + left_edge(1)
          w1 = 1.d0 - abs(l1/dx(1));
          do kk = 1,2
            l2 = 0
            w2 = 1.d0 ]

            weight = CHF_DTERM[w0; *w1; *w2]
            rhoVz(CHF_IX[ii; jj; kk]) = 
     &      rhoVz(CHF_IX[ii; jj; kk]) + vpz * rhop * weight

      CHF_DTERM[
          enddo;
        enddo;
      enddo]

      end

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c  Charge-conserving interpolation of fields to particles using a combination
c  of NGP and CIC interpolation with cell crossings included (needed for energy conservation)
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine cc0_1d_interpolate_fields( CHF_REAL[Epx],
     &                                   CHF_REAL[Epy],
     &                                   CHF_REAL[Epz],
     &                                   CHF_REAL[Bpx],
     &                                   CHF_REAL[Bpy],
     &                                   CHF_REAL[Bpz],
     &                                   CHF_CONST_FRA1[Ex],
     &                                   CHF_CONST_FRA1[Ey],
     &                                   CHF_CONST_FRA1[Ez],
     &                                   CHF_CONST_FRA1[Bx],
     &                                   CHF_CONST_FRA1[By],
     &                                   CHF_CONST_FRA1[Bz],
     &                                   CHF_CONST_REALVECT[left_edge],
     &                                   CHF_CONST_REALVECT[dx],
     &                                   CHF_CONST_REALVECT[xpold],
     &                                   CHF_CONST_REALVECT[xphalf] )

      integer CHF_DDECL[ii_stag;jj_stag;kk_stag]
      REAL_T CHF_DDECL[l0_stag;l1_stag;l2_stag]
      REAL_T CHF_DDECL[w0_stag;w1_stag;w2_stag]
      
      integer index(0:CH_SPACEDIM - 1), index_stag(0:CH_SPACEDIM - 1)
      integer index_stag_old(0:CH_SPACEDIM - 1), index_stag_new(0:CH_SPACEDIM - 1)
      integer cell_crossings(0:CH_SPACEDIM - 1), idir, num_segments
      REAL_T CHF_DDECL[l0;l1;l2], CHF_DDECL[w0;w1;w2]
      REAL_T dXp(0:CH_SPACEDIM - 1), xpold0(0:CH_SPACEDIM - 1)
      REAL_T dXp_sub(0:CH_SPACEDIM - 1), xpnew0(0:CH_SPACEDIM - 1) 
      REAL_T xpnew(0:CH_SPACEDIM - 1), Xcell(0:CH_SPACEDIM - 1)
      REAL_T weight, seg_factor
      integer nn, sign(0:CH_SPACEDIM - 1), i0
      integer ii, jj, kk, ii_next, jj_next, kk_next 

c     compute the new particle position
      do idir = 0, CH_SPACEDIM - 1
        xpnew(idir) = two*xphalf(idir) - xpold(idir)
        dXp(idir) = xpnew(idir) - xpold(idir)
        sign(idir) = 1
      enddo
     
      i0 = 0

c     compute the index of the left most cell/edge that contains this particle cloud
      num_segments = 1
      do idir = 0, CH_SPACEDIM - 1
        index_stag_old(idir) = floor((xpold(idir) - left_edge(idir)) / dx(idir))
        index_stag_new(idir) = floor((xpnew(idir) - left_edge(idir)) / dx(idir))
        if(index_stag_new(idir)<index_stag_old(idir)) then
          sign(idir) = -1
        endif
        cell_crossings(idir) = ABS(index_stag_new(idir) - index_stag_old(idir))
        num_segments = num_segments + cell_crossings(idir)
      enddo

c     calculate the initial Xcell in each direction
      do idir = 0, CH_SPACEDIM -1
        Xcell(idir) = left_edge(idir) + (index_stag_old(idir) + half*(1-sign(idir)))*dx(idir)
      enddo

      xpold0 = xpold
      CHF_DTERM[ii_next=index_stag_old(0); 
                jj_next=index_stag_old(1); 
                kk_next=index_stag_old(2)]

      do nn=0, num_segments-1

        CHF_DTERM[ii=ii_next; 
                  jj=jj_next; 
                  kk=kk_next]

        if(nn==num_segments-1) then
          xpnew0 = xpnew
          dXp_sub = xpnew0 - xpold0
        else
          ii_next = ii + sign(i0)
          Xcell(i0) = Xcell(i0) + sign(i0)*dx(i0)
          xpnew0(i0) = Xcell(i0)
          dXp_sub(i0) = xpnew0(i0) - xpold0(i0)
        endif

c     interpolate Ex to particle
        if(num_segments>1) then
          seg_factor = dXp_sub(i0)/dXp(i0)
        else
          seg_factor = 1.d0
        endif

        weight = seg_factor
        Epx = Epx + weight*Ex(CHF_IX[ii;jj;kk]) 
        
c     update xpold
        xpold0 = xpnew0
            
      enddo

c
c     cloud in cell for Ey, Ez, Bx, By, and Bz
c

      do idir = 0, CH_SPACEDIM - 1
        index(idir) = floor((xphalf(idir) - left_edge(idir) - 0.5d0*dx(idir)) / dx(idir))
        index_stag(idir) = floor((xphalf(idir) - left_edge(idir)) / dx(idir))
      enddo

      CHF_DTERM[
      do ii = index(0), index(0) + 1
        l0 = ii*dx(0) + 0.5d0*dx(0) - xphalf(0) + left_edge(0)
        ii_stag = ii-index(0)+index_stag(0)
        l0_stag = ii_stag*dx(0) - xphalf(0) + left_edge(0)
        w0 = 1.d0 - abs(l0 / dx(0))
        w0_stag = 1.d0 - abs(l0_stag / dx(0));
        do jj = index(1), index(1) + 1
          l1 = jj*dx(1) + 0.5d0*dx(1) - xphalf(1) + left_edge(1)
          jj_stag = jj-index(1)+index_stag(1)
          l1_stag = jj_stag*dx(1) - xphalf(1) + left_edge(1)
          w1 = 1.d0 - abs(l1 / dx(1))
          w1_stag = 1.d0 - abs(l1_stag / dx(1));
          do kk = index(2), index(2) + 1
            l2 = kk*dx(2) + 0.5d0*dx(2) - xphalf(2) + left_edge(2)
            kk_stag = kk-index(2)+index_stag(2)
            l2_stag = kk_stag*dx(2) - xphalf(2) + left_edge(2)
            w2 = 1.d0 - abs(l2 / dx(2))
            w2_stag = 1.d0 - abs(l2_stag / dx(2)) ]
            
            weight = CHF_DTERM[w0_stag; *w1; *w2_stag]
            Epy = Epy + weight*Ey(CHF_IX[ii_stag; jj; kk_stag])

            weight = CHF_DTERM[w0_stag; *w1_stag; *w2]
            Epz = Epz + weight*Ez(CHF_IX[ii_stag; jj_stag; kk])

            weight = CHF_DTERM[w0_stag; *w1; *w2]
            Bpx = Bpx + weight*Bx(CHF_IX[ii_stag; jj; kk])
            
            weight = CHF_DTERM[w0; *w1_stag; *w2]
            Bpy = Bpy + weight*By(CHF_IX[ii; jj_stag; kk])
            
            weight = CHF_DTERM[w0; *w1; *w2_stag]
            Bpz = Bpz + weight*Bz(CHF_IX[ii; jj; kk_stag])

      CHF_DTERM[
          enddo;
        enddo;
      enddo]

      end

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c  Charge-conserving interpolation of fields to particles using a combination
c  of NGP and CIC interpolation with cell crossings included (needed for energy conservation)
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine cc0_2d_interpolate_fields( CHF_REAL[Epx],
     &                                   CHF_REAL[Epy],
     &                                   CHF_REAL[Epz],
     &                                   CHF_REAL[Bpx],
     &                                   CHF_REAL[Bpy],
     &                                   CHF_REAL[Bpz],
     &                                   CHF_CONST_FRA1[Ex],
     &                                   CHF_CONST_FRA1[Ey],
     &                                   CHF_CONST_FRA1[Ez],
     &                                   CHF_CONST_FRA1[Bx],
     &                                   CHF_CONST_FRA1[By],
     &                                   CHF_CONST_FRA1[Bz],
     &                                   CHF_CONST_REALVECT[left_edge],
     &                                   CHF_CONST_REALVECT[dx],
     &                                   CHF_CONST_REALVECT[xpold],
     &                                   CHF_CONST_REALVECT[xphalf] )

      integer CHF_DDECL[ii_stag;jj_stag;kk_stag]
      REAL_T CHF_DDECL[l0_stag;l1_stag;l2_stag]
      REAL_T CHF_DDECL[w0_stag;w1_stag;w2_stag]
      integer index(0:CH_SPACEDIM - 1), index_stag(0:CH_SPACEDIM - 1)
      
      integer index_stag_old(0:CH_SPACEDIM - 1), index_stag_new(0:CH_SPACEDIM - 1)
      integer cell_crossings(0:CH_SPACEDIM - 1), idir, num_segments
      REAL_T CHF_DDECL[l0;l1;l2], CHF_DDECL[w0;w1;w2]
      REAL_T dXp(0:CH_SPACEDIM - 1), xpold0(0:CH_SPACEDIM - 1)
      REAL_T dXp_sub(0:CH_SPACEDIM - 1), xpnew0(0:CH_SPACEDIM - 1) 
      REAL_T xpnew(0:CH_SPACEDIM - 1), Xcell(0:CH_SPACEDIM - 1)
      REAL_T weight, slope, slope_inv, dXp_sub02
      integer nn, sign(0:CH_SPACEDIM - 1), i0, i1
      integer ii, jj, kk, ii_next, jj_next, kk_next 

c     compute the new particle position
      do idir = 0, CH_SPACEDIM - 1
        xpnew(idir) = two*xphalf(idir) - xpold(idir)
        dXp(idir) = xpnew(idir) - xpold(idir)
        sign(idir) = 1
      enddo
     
c     compute slopes assuming 2D
      i0 = 0
      i1 = CH_SPACEDIM-1
      slope = dXp(i1)/dXp(i0)
      slope_inv = 1/slope

c     compute the index of the left most cell/edge that contains this particle cloud
      num_segments = 1
      do idir = 0, CH_SPACEDIM - 1
        index_stag_old(idir) = floor((xpold(idir) - left_edge(idir)) / dx(idir))
        index_stag_new(idir) = floor((xpnew(idir) - left_edge(idir)) / dx(idir))
        if(index_stag_new(idir)<index_stag_old(idir)) then
          sign(idir) = -1
        endif
        cell_crossings(idir) = ABS(index_stag_new(idir) - index_stag_old(idir))
        num_segments = num_segments + cell_crossings(idir)
      enddo

c     calculate the initial Xcell in each direction
      do idir = 0, CH_SPACEDIM -1
        Xcell(idir) = left_edge(idir) + (index_stag_old(idir) + half*(1-sign(idir)))*dx(idir)
      enddo

      xpold0 = xpold
      CHF_DTERM[ii_next=index_stag_old(0); 
                jj_next=index_stag_old(1); 
                kk_next=index_stag_old(2)]

      do nn=0, num_segments-1

        CHF_DTERM[ii=ii_next; 
                  jj=jj_next; 
                  kk=kk_next]

        if(nn==num_segments-1) then
          xpnew0 = xpnew
          dXp_sub = xpnew0 - xpold0
        else if(cell_crossings(i0)==0) then
          jj_next = jj + sign(i1)
          Xcell(i1) = Xcell(i1) + sign(i1)*dx(i1)
          xpnew0(i1) = Xcell(i1)
          dXp_sub(i1) = xpnew0(i1) - xpold0(i1)
          dXp_sub(i0) = slope_inv*dXp_sub(i1)
          xpnew0(i0) = xpold0(i0) + dXp_sub(i0)
        else if(cell_crossings(i1)==0) then
          ii_next = ii + sign(i0)
          Xcell(i0) = Xcell(i0) + sign(i0)*dx(i0)
          xpnew0(i0) = Xcell(i0)
          dXp_sub(i0) = xpnew0(i0) - xpold0(i0)
          dXp_sub(i1) = slope*dXp_sub(i0)
          xpnew0(i1) = xpold0(i1) + dXp_sub(i1)
        else
          xpnew0(i0) = Xcell(i0) + sign(i0)*dx(i0)
          xpnew0(i1) = Xcell(i1) + sign(i1)*dx(i1)
          dXp_sub(i0) = xpnew0(i0) - xpold0(i0)
          dXp_sub(i1) = xpnew0(i1) - xpold0(i1)
          dXp_sub02 = slope_inv*dXp_sub(i1)

          if(abs(dXp_sub(i0))<abs(dXp_sub02)) then
            dXp_sub(i1) = slope*dXp_sub(i0)
            xpnew0(i1) = xpold0(i1) + dXp_sub(i1)
            Xcell(i0) = xpnew0(i0)
            ii_next = ii + sign(i0)
            cell_crossings(i0) = cell_crossings(i0) - 1
          else
            dXp_sub(i0) = slope_inv*dXp_sub(i1)
            xpnew0(i0) = xpold0(i0) + dXp_sub(i0)
            Xcell(i1) = xpnew0(i1)
            jj_next = jj + sign(i1)
            cell_crossings(i1) = cell_crossings(i1) - 1
          endif

        endif

        CHF_DTERM[l0 = half*(xpold0(0)+xpnew0(0)) - (left_edge(0) + ii*dx(0));
                  l1 = half*(xpold0(1)+xpnew0(1)) - (left_edge(1) + jj*dx(1));
                  l2 = half*(xpold0(2)+xpnew0(2)) - (left_edge(2) + kk*dx(2))]

c     interpolate Ex to particle
        if(num_segments>1) then
          CHF_DTERM[w0 = dXp_sub(i0)/dXp(i0);
                    w1 = 1.d0 - l1/dx(1);
                    w2 = 0.0]
        else
          CHF_DTERM[w0 = 1.d0;
                    w1 = 1.d0 - l1/dx(1);
                    w2 = 0.0]
        endif

        weight = CHF_DTERM[w0; *w1; *w2]
        Epx = Epx + weight*Ex(CHF_IX[ii;jj;kk]) 
        
        weight = CHF_DTERM[w0; *(1.d0-w1); *w2]
        Epx = Epx + weight*Ex(CHF_IX[ii;jj+1;kk])

c     interpolate Ey to particle
        if(num_segments>1) then
          CHF_DTERM[w0 = 1.d0 - l0/dx(0);
                    w1 = dXp_sub(i1)/dXp(i1);
                    w2 = 1.d0]
        else
          CHF_DTERM[w0 = 1.d0 - l0/dx(0);
                    w1 = 1.d0;
                    w2 = 1.d0]
        endif
        
        weight = CHF_DTERM[w0; *w1; *w2]
        Epy = Epy + weight*Ey(CHF_IX[ii;jj;kk]) 
        
        weight = CHF_DTERM[(1.d0-w0); *w1; *w2]
        Epy = Epy + weight*Ey(CHF_IX[ii+1;jj;kk])

c     update xpold
        xpold0 = xpnew0
            
      enddo

c
c     cloud in cell for Ez, Bx, By, and Bz
c

      do idir = 0, CH_SPACEDIM - 1
        index(idir) = floor((xphalf(idir) - left_edge(idir) - 0.5d0*dx(idir)) / dx(idir))
        index_stag(idir) = floor((xphalf(idir) - left_edge(idir)) / dx(idir))
      enddo

      CHF_DTERM[
      do ii = index(0), index(0) + 1
        l0 = ii*dx(0) + 0.5d0*dx(0) - xphalf(0) + left_edge(0)
        ii_stag = ii-index(0)+index_stag(0)
        l0_stag = ii_stag*dx(0) - xphalf(0) + left_edge(0)
        w0 = 1.d0 - abs(l0 / dx(0))
        w0_stag = 1.d0 - abs(l0_stag / dx(0));
        do jj = index(1), index(1) + 1
          l1 = jj*dx(1) + 0.5d0*dx(1) - xphalf(1) + left_edge(1)
          jj_stag = jj-index(1)+index_stag(1)
          l1_stag = jj_stag*dx(1) - xphalf(1) + left_edge(1)
          w1 = 1.d0 - abs(l1 / dx(1))
          w1_stag = 1.d0 - abs(l1_stag / dx(1));
          do kk = index(2), index(2) + 1
            l2 = kk*dx(2) + 0.5d0*dx(2) - xphalf(2) + left_edge(2)
            kk_stag = kk-index(2)+index_stag(2)
            l2_stag = kk_stag*dx(2) - xphalf(2) + left_edge(2)
            w2 = 1.d0 - abs(l2 / dx(2))
            w2_stag = 1.d0 - abs(l2_stag / dx(2)) ]

            weight = CHF_DTERM[w0_stag; *w1_stag; *w2]
            Epz = Epz + weight*Ez(CHF_IX[ii_stag; jj_stag; kk])

            weight = CHF_DTERM[w0_stag; *w1; *w2]
            Bpx = Bpx + weight*Bx(CHF_IX[ii_stag; jj; kk])
            
            weight = CHF_DTERM[w0; *w1_stag; *w2]
            Bpy = Bpy + weight*By(CHF_IX[ii; jj_stag; kk])
            
            weight = CHF_DTERM[w0; *w1; *w2_stag]
            Bpz = Bpz + weight*Bz(CHF_IX[ii; jj; kk_stag])

      CHF_DTERM[
          enddo;
        enddo;
      enddo]

      end

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c  Charge-conserving deposit for particle current density using a combination
c  of CIC and TSC interpolation with cell crossings included
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine cc1_1d_deposit_current(
     &                       CHF_FRA1[rhoVx],
     &                       CHF_FRA1[rhoVy],
     &                       CHF_FRA1[rhoVz],
     &                       CHF_CONST_REALVECT[left_edge],
     &                       CHF_CONST_REALVECT[dx],
     &                       CHF_CONST_REALVECT[xpold],
     &                       CHF_CONST_REALVECT[xphalf],
     &                       CHF_CONST_REAL[vpx], 
     &                       CHF_CONST_REAL[vpy], 
     &                       CHF_CONST_REAL[vpz], 
     &                       CHF_CONST_REAL[qp]) 

      integer index(0:CH_SPACEDIM - 1), index_stag(0:CH_SPACEDIM - 1)
      integer index_old(0:CH_SPACEDIM - 1), index_new(0:CH_SPACEDIM - 1)
      integer cell_crossings(0:CH_SPACEDIM - 1), idir, num_segments
      REAL_T CHF_DDECL[l0;l1;l2], CHF_DDECL[w0;w1;w2]
      REAL_T dXp(0:CH_SPACEDIM - 1), xpold0(0:CH_SPACEDIM - 1), xphalf0(0:CH_SPACEDIM - 1)
      REAL_T dXp_sub(0:CH_SPACEDIM - 1), xpnew0(0:CH_SPACEDIM - 1) 
      REAL_T xpnew(0:CH_SPACEDIM - 1), Xcell(0:CH_SPACEDIM - 1)
      REAL_T volume, rhop, weight, seg_factor
      integer nn, sign(0:CH_SPACEDIM - 1), i0
      integer ii, jj, kk, ii_next, jj_next, kk_next 

c     compute the cell volume and particle density on the grid
      volume = CHF_DTERM[dx(0);*dx(1);*dx(2)]
      rhop = qp / volume

c     compute the new particle position
      do idir = 0, CH_SPACEDIM - 1
        xpnew(idir) = two*xphalf(idir) - xpold(idir)
        dXp(idir) = xpnew(idir) - xpold(idir)
        sign(idir) = 1
      enddo
     
      i0 = 0

c     compute the index of the left most cell/edge that contains this particle cloud
      num_segments = 1
      do idir = 0, CH_SPACEDIM - 1
        index_old(idir) = floor((xpold(idir) - left_edge(idir) - 0.5d0*dx(idir)) / dx(idir))
        index_new(idir) = floor((xpnew(idir) - left_edge(idir) - 0.5d0*dx(idir)) / dx(idir))
        if(index_new(idir)<index_old(idir)) then
          sign(idir) = -1
        endif
        cell_crossings(idir) = ABS(index_new(idir) - index_old(idir))
        num_segments = num_segments + cell_crossings(idir)
      enddo

c     calculate the initial Xcell in each direction
      do idir = 0, CH_SPACEDIM -1
        Xcell(idir) = left_edge(idir) + (index_old(idir) + half*(1-sign(idir)) + 0.5)*dx(idir)
      enddo

      xpold0 = xpold
      CHF_DTERM[ii_next=index_old(0); 
                jj_next=index_old(1); 
                kk_next=index_old(2)]

      do nn=0, num_segments-1

        CHF_DTERM[ii=ii_next; 
                  jj=jj_next; 
                  kk=kk_next]

        if(nn==num_segments-1) then
          xpnew0 = xpnew
          dXp_sub = xpnew0 - xpold0
        else
          ii_next = ii + sign(i0)
          Xcell(i0) = Xcell(i0) + sign(i0)*dx(i0)
          xpnew0(i0) = Xcell(i0)
          dXp_sub(i0) = xpnew0(i0) - xpold0(i0)
        endif
        
c     deposit the particle x-current to the grid
        if(num_segments>1) then
          seg_factor = dXp_sub(i0)/dXp(i0)
        else
          seg_factor = 1.d0
        endif
        
        xphalf0(i0) = half*(xpnew0(i0) + xpold0(i0))
        l0 = left_edge(i0) + ii*dx(i0) + 0.5d0*dx(i0) - xphalf0(i0)
        w0 = 1.d0 - abs(l0/dx(i0))

        weight = w0*seg_factor
        rhoVx(CHF_IX[ii; jj; kk]) = 
     &  rhoVx(CHF_IX[ii; jj; kk]) + vpx * rhop * weight
        
        weight = (1.d0-w0)*seg_factor
        rhoVx(CHF_IX[ii+1; jj; kk]) = 
     &  rhoVx(CHF_IX[ii+1; jj; kk]) + vpx * rhop * weight
        
c     update xpold
        xpold0 = xpnew0
            
      enddo

c
c     deposit the particle y an z current to the grid
c

      do idir = 0, CH_SPACEDIM - 1
        index_stag(idir) = floor((xphalf(idir) - left_edge(idir)) / dx(idir))
      enddo

      CHF_DTERM[
      do ii = index_stag(0), index_stag(0) + 1
        l0 = ii*dx(0) - xphalf(0) + left_edge(0)
        w0 = 1.d0 - abs(l0/dx(0));
        do jj = 1,2
          l1 = 0
          w1 = 1.d0;
          do kk = 1,2
            l2 = 0
            w2 = 1.d0 ]

            weight = CHF_DTERM[w0; *w1; *w2]
            rhoVy(CHF_IX[ii; jj; kk]) = 
     &      rhoVy(CHF_IX[ii; jj; kk]) + vpy * rhop * weight

            rhoVz(CHF_IX[ii; jj; kk]) = 
     &      rhoVz(CHF_IX[ii; jj; kk]) + vpz * rhop * weight

      CHF_DTERM[
          enddo;
        enddo;
      enddo]

      end

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c  Charge-conserving interpolation of fields to particles using a combination
c  of CIC and TSC interpolation with cell crossings included (needed for energy conservation)
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine cc1_1d_interpolate_fields( CHF_REAL[Epx],
     &                                   CHF_REAL[Epy],
     &                                   CHF_REAL[Epz],
     &                                   CHF_REAL[Bpx],
     &                                   CHF_REAL[Bpy],
     &                                   CHF_REAL[Bpz],
     &                                   CHF_CONST_FRA1[Ex],
     &                                   CHF_CONST_FRA1[Ey],
     &                                   CHF_CONST_FRA1[Ez],
     &                                   CHF_CONST_FRA1[Bx],
     &                                   CHF_CONST_FRA1[By],
     &                                   CHF_CONST_FRA1[Bz],
     &                                   CHF_CONST_REALVECT[left_edge],
     &                                   CHF_CONST_REALVECT[dx],
     &                                   CHF_CONST_REALVECT[xpold],
     &                                   CHF_CONST_REALVECT[xphalf] )

      integer CHF_DDECL[ii_stag;jj_stag;kk_stag]
      REAL_T CHF_DDECL[l0_stag;l1_stag;l2_stag]
      REAL_T CHF_DDECL[w0_stag;w1_stag;w2_stag]
      
      integer index(0:CH_SPACEDIM - 1), index_stag(0:CH_SPACEDIM - 1)
      integer index_old(0:CH_SPACEDIM - 1), index_new(0:CH_SPACEDIM - 1)
      integer cell_crossings(0:CH_SPACEDIM - 1), idir, num_segments
      REAL_T CHF_DDECL[l0;l1;l2], CHF_DDECL[w0;w1;w2]
      REAL_T dXp(0:CH_SPACEDIM - 1), xpold0(0:CH_SPACEDIM - 1)
      REAL_T dXp_sub(0:CH_SPACEDIM - 1), xpnew0(0:CH_SPACEDIM - 1) 
      REAL_T xpnew(0:CH_SPACEDIM - 1), Xcell(0:CH_SPACEDIM - 1)
      REAL_T weight, dXp_sub02, seg_factor, xphalf0(0:CH_SPACEDIM - 1)
      integer nn, sign(0:CH_SPACEDIM - 1), i0
      integer ii, jj, kk, ii_next, jj_next, kk_next 

c     compute the new particle position
      do idir = 0, CH_SPACEDIM - 1
        xpnew(idir) = two*xphalf(idir) - xpold(idir)
        dXp(idir) = xpnew(idir) - xpold(idir)
        sign(idir) = 1
      enddo
     
      i0 = 0

c     compute the index of the left most cell/edge that contains this particle cloud
      num_segments = 1
      do idir = 0, CH_SPACEDIM - 1
        index_old(idir) = floor((xpold(idir) - left_edge(idir) - 0.5d0*dx(idir)) / dx(idir))
        index_new(idir) = floor((xpnew(idir) - left_edge(idir) - 0.5d0*dx(idir)) / dx(idir))
        if(index_new(idir)<index_old(idir)) then
          sign(idir) = -1
        endif
        cell_crossings(idir) = ABS(index_new(idir) - index_old(idir))
        num_segments = num_segments + cell_crossings(idir)
      enddo

c     calculate the initial Xcell in each direction
      do idir = 0, CH_SPACEDIM -1
        Xcell(idir) = left_edge(idir) + (index_old(idir) + half*(1-sign(idir)) + 0.5)*dx(idir)
      enddo

      xpold0 = xpold
      CHF_DTERM[ii_next=index_old(0); 
                jj_next=index_old(1); 
                kk_next=index_old(2)]

      do nn=0, num_segments-1

        CHF_DTERM[ii=ii_next; 
                  jj=jj_next; 
                  kk=kk_next]

        if(nn==num_segments-1) then
          xpnew0 = xpnew
          dXp_sub = xpnew0 - xpold0
        else
          ii_next = ii + sign(i0)
          Xcell(i0) = Xcell(i0) + sign(i0)*dx(i0)
          xpnew0(i0) = Xcell(i0)
          dXp_sub(i0) = xpnew0(i0) - xpold0(i0)
        endif
        
        xphalf0(i0) = half*(xpnew0(i0) + xpold0(i0))
        l0 = left_edge(i0) + ii*dx(i0) + 0.5d0*dx(i0) - xphalf0(i0)
        w0 = 1.d0 - abs(l0/dx(i0))

c     interpolate Ex to particle
        if(num_segments>1) then
          seg_factor = dXp_sub(i0)/dXp(i0)
        else
          seg_factor = 1.d0
        endif

        weight = w0*seg_factor
        Epx = Epx + weight*Ex(CHF_IX[ii; jj; kk]) 
        
        weight = (1.d0-w0)*seg_factor
        Epx = Epx + weight*Ex(CHF_IX[ii+1; jj; kk])
        
c     update xpold
        xpold0 = xpnew0
            
      enddo

c      
c     cloud in cell for Ey, Ez, Bx, By, and Bz
c

      do idir = 0, CH_SPACEDIM - 1
        index_stag(idir) = floor((xphalf(idir) - left_edge(idir)) / dx(idir))
        index(idir) = floor((xphalf(idir) - left_edge(idir) - 0.5d0*dx(idir)) / dx(idir))
      enddo

      CHF_DTERM[
      do ii = index(0), index(0) + 1
        l0 = ii*dx(0) + 0.5d0*dx(0) - xphalf(0) + left_edge(0)
        ii_stag = ii-index(0)+index_stag(0)
        l0_stag = ii_stag*dx(0) - xphalf(0) + left_edge(0)
        w0 = 1.d0 - abs(l0 / dx(0))
        w0_stag = 1.d0 - abs(l0_stag / dx(0));
        do jj = index(1), index(1) + 1
          l1 = jj*dx(1) + 0.5d0*dx(1) - xphalf(1) + left_edge(1)
          jj_stag = jj-index(1)+index_stag(1)
          l1_stag = jj_stag*dx(1) - xphalf(1) + left_edge(1)
          w1 = 1.d0 - abs(l1 / dx(1))
          w1_stag = 1.d0 - abs(l1_stag / dx(1));
          do kk = index(2), index(2) + 1
            l2 = kk*dx(2) + 0.5d0*dx(2) - xphalf(2) + left_edge(2)
            kk_stag = kk-index(2)+index_stag(2)
            l2_stag = kk_stag*dx(2) - xphalf(2) + left_edge(2)
            w2 = 1.d0 - abs(l2 / dx(2))
            w2_stag = 1.d0 - abs(l2_stag / dx(2))]

            weight = CHF_DTERM[w0_stag; *w1; *w2_stag]
            Epy = Epy + weight*Ey(CHF_IX[ii_stag; jj; kk_stag])

            weight = CHF_DTERM[w0_stag; *w1_stag; *w2]
            Epz = Epz + weight*Ez(CHF_IX[ii_stag; jj_stag; kk])

            weight = CHF_DTERM[w0_stag; *w1; *w2]
            Bpx = Bpx + weight*Bx(CHF_IX[ii_stag; jj; kk])
            
            weight = CHF_DTERM[w0; *w1_stag; *w2]
            Bpy = Bpy + weight*By(CHF_IX[ii; jj_stag; kk])
            
            weight = CHF_DTERM[w0; *w1; *w2_stag]
            Bpz = Bpz + weight*Bz(CHF_IX[ii; jj; kk_stag])

      CHF_DTERM[
          enddo;
        enddo;
      enddo]

      end

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine cc1_2d_deposit_current(
     &                       CHF_FRA1[rhoVx],
     &                       CHF_FRA1[rhoVy],
     &                       CHF_FRA1[rhoVz],
     &                       CHF_CONST_REALVECT[left_edge],
     &                       CHF_CONST_REALVECT[dx],
     &                       CHF_CONST_REALVECT[xpold],
     &                       CHF_CONST_REALVECT[xphalf],
     &                       CHF_CONST_REAL[vpx], 
     &                       CHF_CONST_REAL[vpy], 
     &                       CHF_CONST_REAL[vpz], 
     &                       CHF_CONST_REAL[qp]) 

      integer index_stag(0:CH_SPACEDIM - 1)
      integer index_start(0:CH_SPACEDIM - 1), index_end(0:CH_SPACEDIM - 1)
      integer index_old(0:CH_SPACEDIM - 1), index_new(0:CH_SPACEDIM - 1)
      integer cell_crossings(0:CH_SPACEDIM - 1), idir, num_segments
      REAL_T l0, l1, w0, w1, delta0, delta1
      REAL_T dXp(0:CH_SPACEDIM - 1), xpold0(0:CH_SPACEDIM - 1)
      REAL_T dXp_sub(0:CH_SPACEDIM - 1), xpnew0(0:CH_SPACEDIM - 1)
      REAL_T xphalf0(0:CH_SPACEDIM - 1), seg_factor(0:CH_SPACEDIM - 1)
      REAL_T xpnew(0:CH_SPACEDIM - 1), Xcell(0:CH_SPACEDIM - 1)
      REAL_T volume, rhop, weight, slope, slope_inv, dXp_sub02
      integer nn, sign(0:CH_SPACEDIM - 1), i0, i1
      integer ii, jj, kk, ii_next, jj_next, kk_next 
      integer ii_stag, jj_stag
      REAL_T w0_stag, w1_stag, l0_stag, l1_stag, delta0_stag, delta1_stag

c     compute the cell volume and particle density on the grid
      volume = CHF_DTERM[dx(0);*dx(1);*dx(2)]
      rhop = qp / volume

c     compute the new particle position
      do idir = 0, CH_SPACEDIM - 1
        xpnew(idir) = two*xphalf(idir) - xpold(idir)
        dXp(idir) = xpnew(idir) - xpold(idir)
        sign(idir) = 1
      enddo
     
c     compute slopes assuming 2D
      i0 = 0
      i1 = CH_SPACEDIM-1
      slope = dXp(i1)/dXp(i0)
      slope_inv = 1/slope

c     compute the index of the left most cell/edge that contains this particle cloud
      num_segments = 1
      do idir = 0, CH_SPACEDIM - 1
        index_old(idir) = floor((xpold(idir) - left_edge(idir) - 0.5d0*dx(idir)) / dx(idir))
        index_new(idir) = floor((xpnew(idir) - left_edge(idir) - 0.5d0*dx(idir)) / dx(idir))
        if(index_new(idir)<index_old(idir)) then
          sign(idir) = -1
        endif
        cell_crossings(idir) = ABS(index_new(idir) - index_old(idir))
        num_segments = num_segments + cell_crossings(idir)
      enddo

c     calculate the initial Xcell in each direction
      do idir = 0, CH_SPACEDIM -1
        Xcell(idir) = left_edge(idir) + (index_old(idir) + half*(1-sign(idir)) + 0.5)*dx(idir)
      enddo

      xpold0 = xpold
      CHF_DTERM[ii_next=index_old(0); 
                jj_next=index_old(1); 
                kk_next=index_old(2)]

      do nn=0, num_segments-1

        CHF_DTERM[ii=ii_next; 
                  jj=jj_next; 
                  kk=kk_next]

        if(nn==num_segments-1) then
          xpnew0 = xpnew
          dXp_sub = xpnew0 - xpold0
        else if(cell_crossings(i0)==0) then
          jj_next = jj + sign(i1)
          Xcell(i1) = Xcell(i1) + sign(i1)*dx(i1)
          xpnew0(i1) = Xcell(i1)
          dXp_sub(i1) = xpnew0(i1) - xpold0(i1)
          dXp_sub(i0) = slope_inv*dXp_sub(i1)
          xpnew0(i0) = xpold0(i0) + dXp_sub(i0)
        else if(cell_crossings(i1)==0) then
          ii_next = ii + sign(i0)
          Xcell(i0) = Xcell(i0) + sign(i0)*dx(i0)
          xpnew0(i0) = Xcell(i0)
          dXp_sub(i0) = xpnew0(i0) - xpold0(i0)
          dXp_sub(i1) = slope*dXp_sub(i0)
          xpnew0(i1) = xpold0(i1) + dXp_sub(i1)
        else
          xpnew0(i0) = Xcell(i0) + sign(i0)*dx(i0)
          xpnew0(i1) = Xcell(i1) + sign(i1)*dx(i1)
          dXp_sub(i0) = xpnew0(i0) - xpold0(i0)
          dXp_sub(i1) = xpnew0(i1) - xpold0(i1)
          dXp_sub02 = slope_inv*dXp_sub(i1)

          if(abs(dXp_sub(i0))<abs(dXp_sub02)) then
            dXp_sub(i1) = slope*dXp_sub(i0)
            xpnew0(i1) = xpold0(i1) + dXp_sub(i1)
            Xcell(i0) = xpnew0(i0)
            ii_next = ii + sign(i0)
            cell_crossings(i0) = cell_crossings(i0) - 1
          else
            dXp_sub(i0) = slope_inv*dXp_sub(i1)
            xpnew0(i0) = xpold0(i0) + dXp_sub(i0)
            Xcell(i1) = xpnew0(i1)
            jj_next = jj + sign(i1)
            cell_crossings(i1) = cell_crossings(i1) - 1
          endif

        endif

        if(num_segments>1) then
          seg_factor(i0) = dXp_sub(i0)/dXp(i0)
          seg_factor(i1) = dXp_sub(i1)/dXp(i1)
        else
          seg_factor(i0) = 1.d0
          seg_factor(i1) = 1.d0
        endif        

c     compute CIC weights
        xphalf0 = half*(xpold0 + xpnew0)
        delta0 = (xphalf0(i0) - (left_edge(i0) + (ii+0.5)*dx(i0)))/dx(i0)
        delta1 = (xphalf0(i1) - (left_edge(i1) + (jj+0.5)*dx(i1)))/dx(i1)

c     get indicies for TSC weights
        do idir = 0, CH_SPACEDIM -1
          index_new(idir) = floor((xpnew0(idir) - left_edge(idir) - 0.5d0*dx(idir)) / dx(idir))
          index_start(idir) = min(index_old(idir),index_new(idir))
          index_end(idir) = max(index_old(idir),index_new(idir)) + 2
          index_old(idir) = index_new(idir)
        enddo
  
c     deposit the particle x-current to the grid
        do jj_stag=index_start(i1), index_end(i1)

          l1_stag = jj_stag*dx(i1) - xpold0(i1) + left_edge(i1)
          delta1_stag = abs(l1_stag/dx(i1))
          if (delta1_stag .lt. 0.5d0) then
            w1_stag = 0.75d0 - delta1_stag**2.d0
          else if (delta1_stag .lt. 1.5d0) then
            w1_stag = 0.5d0 * (1.5d0 - delta1_stag)**2.d0
          else
            w1_stag = 0.0
          endif

          l1_stag = jj_stag*dx(i1) - xpnew0(i1) + left_edge(i1)
          delta1_stag = abs(l1_stag/dx(i1))
          if (delta1_stag .lt. 0.5d0) then
            w1_stag = w1_stag + 0.75d0 - delta1_stag**2.d0
          else if (delta1_stag .lt. 1.5d0) then
            w1_stag = w1_stag + 0.5d0 * (1.5d0 - delta1_stag)**2.d0
          endif
          w1_stag = half*w1_stag

          weight = (1.0 - delta0)*w1_stag*seg_factor(i0)
          rhoVx(CHF_IX[ii; jj_stag; kk]) = 
     &    rhoVx(CHF_IX[ii; jj_stag; kk]) + vpx * rhop * weight
        
          weight = delta0*w1_stag*seg_factor(i0)
          rhoVx(CHF_IX[ii+1; jj_stag; kk]) = 
     &    rhoVx(CHF_IX[ii+1; jj_stag; kk]) + vpx * rhop * weight

        enddo

c     deposit the particle y-current to the grid
        do ii_stag=index_start(i0), index_end(i0)

          l0_stag = ii_stag*dx(i0) - xpold0(i0) + left_edge(i0)
          delta0_stag = abs(l0_stag/dx(i0))
          if (delta0_stag .lt. 0.5d0) then
            w0_stag = 0.75d0 - delta0_stag**2.d0
          else if (delta0_stag .lt. 1.5d0) then
            w0_stag = 0.5d0 * (1.5d0 - delta0_stag)**2.d0
          else
            w0_stag = 0.0
          endif
          
          l0_stag = ii_stag*dx(i0) - xpnew0(i0) + left_edge(i0)
          delta0_stag = abs(l0_stag/dx(i0))
          if (delta0_stag .lt. 0.5d0) then
            w0_stag = w0_stag + 0.75d0 - delta0_stag**2.d0
          else if (delta0_stag .lt. 1.5d0) then
            w0_stag = w0_stag + 0.5d0 * (1.5d0 - delta0_stag)**2.d0
          endif
          w0_stag = half*w0_stag

          weight = w0_stag*(1.0 - delta1)*seg_factor(i1)
          rhoVy(CHF_IX[ii_stag; jj; kk]) = 
     &    rhoVy(CHF_IX[ii_stag; jj; kk]) + vpy * rhop * weight
        
          weight = w0_stag*delta1*seg_factor(i1)
          rhoVy(CHF_IX[ii_stag; jj+1; kk]) = 
     &    rhoVy(CHF_IX[ii_stag; jj+1; kk]) + vpy * rhop * weight
        
        enddo

c     update xpold
        xpold0 = xpnew0
            
      enddo

c
c     deposit the particle z-current to the grid
c

      do idir = 0, CH_SPACEDIM - 1
        index_stag(idir) = floor((xphalf(idir) - left_edge(idir)) / dx(idir))
      enddo

      CHF_DTERM[
      do ii = index_stag(0), index_stag(0) + 1
        delta0 = (ii*dx(0) - xphalf(0) + left_edge(0))/dx(0)
        w0 = 1.d0 - abs(delta0);
        do jj = index_stag(1), index_stag(1) + 1
          delta1 = (jj*dx(1) - xphalf(1) + left_edge(1))/dx(1)
          w1 = 1.d0 - abs(delta1);
          do kk = 1,2]

            weight = w0*w1
            rhoVz(CHF_IX[ii; jj; kk]) = 
     &      rhoVz(CHF_IX[ii; jj; kk]) + vpz * rhop * weight

      CHF_DTERM[
          enddo;
        enddo;
      enddo]

      end

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c  Charge-conserving interpolation of fields to particles using a combination
c  of CIC and TSC interpolation with cell crossings included (needed for energy conservation)
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine cc1_2d_interpolate_fields( CHF_REAL[Epx],
     &                                   CHF_REAL[Epy],
     &                                   CHF_REAL[Epz],
     &                                   CHF_REAL[Bpx],
     &                                   CHF_REAL[Bpy],
     &                                   CHF_REAL[Bpz],
     &                                   CHF_CONST_FRA1[Ex],
     &                                   CHF_CONST_FRA1[Ey],
     &                                   CHF_CONST_FRA1[Ez],
     &                                   CHF_CONST_FRA1[Bx],
     &                                   CHF_CONST_FRA1[By],
     &                                   CHF_CONST_FRA1[Bz],
     &                                   CHF_CONST_REALVECT[left_edge],
     &                                   CHF_CONST_REALVECT[dx],
     &                                   CHF_CONST_REALVECT[xpold],
     &                                   CHF_CONST_REALVECT[xphalf] )

      integer ii_stag, jj_stag, kk_stag
      REAL_T l0_stag, l1_stag, delta0_stag, delta1_stag
      REAL_T w0_stag, w1_stag, w2_stag
      integer index(0:CH_SPACEDIM - 1), index_stag(0:CH_SPACEDIM - 1)
      integer index_start(0:CH_SPACEDIM - 1), index_end(0:CH_SPACEDIM - 1)
      integer index_old(0:CH_SPACEDIM - 1), index_new(0:CH_SPACEDIM - 1)
      integer cell_crossings(0:CH_SPACEDIM - 1), idir, num_segments
      REAL_T l0, l1, l2, w0, w1, w2, delta0, delta1, seg_factor(0:CH_SPACEDIM - 1)
      REAL_T dXp(0:CH_SPACEDIM - 1), xpold0(0:CH_SPACEDIM - 1), xphalf0(0:CH_SPACEDIM - 1)
      REAL_T dXp_sub(0:CH_SPACEDIM - 1), xpnew0(0:CH_SPACEDIM - 1) 
      REAL_T xpnew(0:CH_SPACEDIM - 1), Xcell(0:CH_SPACEDIM - 1)
      REAL_T weight, slope, slope_inv, dXp_sub02
      integer nn, sign(0:CH_SPACEDIM - 1), i0, i1
      integer ii, jj, kk, ii_next, jj_next, kk_next 

c     compute the new particle position
      do idir = 0, CH_SPACEDIM - 1
        xpnew(idir) = two*xphalf(idir) - xpold(idir)
        dXp(idir) = xpnew(idir) - xpold(idir)
        sign(idir) = 1
      enddo
     
c     compute slopes assuming 2D
      i0 = 0
      i1 = CH_SPACEDIM-1
      slope = dXp(i1)/dXp(i0)
      slope_inv = 1/slope

c     compute the index of the left most cell/edge that contains this particle cloud
      num_segments = 1
      do idir = 0, CH_SPACEDIM - 1
        index_old(idir) = floor((xpold(idir) - left_edge(idir) - 0.5d0*dx(idir)) / dx(idir))
        index_new(idir) = floor((xpnew(idir) - left_edge(idir) - 0.5d0*dx(idir)) / dx(idir))
        if(index_new(idir)<index_old(idir)) then
          sign(idir) = -1
        endif
        cell_crossings(idir) = ABS(index_new(idir) - index_old(idir))
        num_segments = num_segments + cell_crossings(idir)
      enddo

c     calculate the initial Xcell in each direction
      do idir = 0, CH_SPACEDIM -1
        Xcell(idir) = left_edge(idir) + (index_old(idir) + half*(1-sign(idir)) + 0.5)*dx(idir)
      enddo

      xpold0 = xpold
      CHF_DTERM[ii_next=index_old(0); 
                jj_next=index_old(1); 
                kk_next=index_old(2)]

      do nn=0, num_segments-1

        CHF_DTERM[ii=ii_next; 
                  jj=jj_next; 
                  kk=kk_next]

        if(nn==num_segments-1) then
          xpnew0 = xpnew
          dXp_sub = xpnew0 - xpold0
        else if(cell_crossings(i0)==0) then
          jj_next = jj + sign(i1)
          Xcell(i1) = Xcell(i1) + sign(i1)*dx(i1)
          xpnew0(i1) = Xcell(i1)
          dXp_sub(i1) = xpnew0(i1) - xpold0(i1)
          dXp_sub(i0) = slope_inv*dXp_sub(i1)
          xpnew0(i0) = xpold0(i0) + dXp_sub(i0)
        else if(cell_crossings(i1)==0) then
          ii_next = ii + sign(i0)
          Xcell(i0) = Xcell(i0) + sign(i0)*dx(i0)
          xpnew0(i0) = Xcell(i0)
          dXp_sub(i0) = xpnew0(i0) - xpold0(i0)
          dXp_sub(i1) = slope*dXp_sub(i0)
          xpnew0(i1) = xpold0(i1) + dXp_sub(i1)
        else
          xpnew0(i0) = Xcell(i0) + sign(i0)*dx(i0)
          xpnew0(i1) = Xcell(i1) + sign(i1)*dx(i1)
          dXp_sub(i0) = xpnew0(i0) - xpold0(i0)
          dXp_sub(i1) = xpnew0(i1) - xpold0(i1)
          dXp_sub02 = slope_inv*dXp_sub(i1)

          if(abs(dXp_sub(i0))<abs(dXp_sub02)) then
            dXp_sub(i1) = slope*dXp_sub(i0)
            xpnew0(i1) = xpold0(i1) + dXp_sub(i1)
            Xcell(i0) = xpnew0(i0)
            ii_next = ii + sign(i0)
            cell_crossings(i0) = cell_crossings(i0) - 1
          else
            dXp_sub(i0) = slope_inv*dXp_sub(i1)
            xpnew0(i0) = xpold0(i0) + dXp_sub(i0)
            Xcell(i1) = xpnew0(i1)
            jj_next = jj + sign(i1)
            cell_crossings(i1) = cell_crossings(i1) - 1
          endif

        endif

        if(num_segments>1) then
          seg_factor(i0) = dXp_sub(i0)/dXp(i0)
          seg_factor(i1) = dXp_sub(i1)/dXp(i1)
        else
          seg_factor(i0) = 1.d0
          seg_factor(i1) = 1.d0
        endif

c     compute CIC weights
        xphalf0 = half*(xpold0 + xpnew0)
        delta0 = (xphalf0(i0) - (left_edge(i0) + (ii+0.5)*dx(i0)))/dx(i0)
        delta1 = (xphalf0(i1) - (left_edge(i1) + (jj+0.5)*dx(i1)))/dx(i1)

c     get indicies for TSC weights
        do idir = 0, CH_SPACEDIM -1
          index_new(idir) = floor((xpnew0(idir) - left_edge(idir) - 0.5d0*dx(idir)) / dx(idir))
          index_start(idir) = min(index_old(idir),index_new(idir))
          index_end(idir) = max(index_old(idir),index_new(idir)) + 2
          index_old(idir) = index_new(idir)
        enddo

c     interpolate Ex to particle
        do jj_stag=index_start(i1), index_end(i1)

          l1_stag = jj_stag*dx(i1) - xpold0(i1) + left_edge(i1)
          delta1_stag = abs(l1_stag/dx(i1))
          if (delta1_stag .lt. 0.5d0) then
            w1_stag = 0.75d0 - delta1_stag**2.d0
          else if (delta1_stag .lt. 1.5d0) then
            w1_stag = 0.5d0 * (1.5d0 - delta1_stag)**2.d0
          else
            w1_stag = 0.0
          endif

          l1_stag = jj_stag*dx(i1) - xpnew0(i1) + left_edge(i1)
          delta1_stag = abs(l1_stag/dx(i1))
          if (delta1_stag .lt. 0.5d0) then
            w1_stag = w1_stag + 0.75d0 - delta1_stag**2.d0
          else if (delta1_stag .lt. 1.5d0) then
            w1_stag = w1_stag + 0.5d0 * (1.5d0 - delta1_stag)**2.d0
          endif
          w1_stag = half*w1_stag

          weight = (1.0 - delta0)*w1_stag*seg_factor(i0)
          Epx = Epx + weight*Ex(CHF_IX[ii;jj_stag;kk]) 
        
          weight = delta0*w1_stag*seg_factor(i0)
          Epx = Epx + weight*Ex(CHF_IX[ii+1;jj_stag;kk])

        enddo

c     interpolate Ey to particle
        do ii_stag=index_start(i0), index_end(i0)+2

          l0_stag = ii_stag*dx(i0) - xpold0(i0) + left_edge(i0)
          delta0_stag = abs(l0_stag/dx(i0))
          if (delta0_stag .lt. 0.5d0) then
            w0_stag = 0.75d0 - delta0_stag**2.d0
          else if (delta0_stag .lt. 1.5d0) then
            w0_stag = 0.5d0 * (1.5d0 - delta0_stag)**2.d0
          else
            w0_stag = 0.0
          endif

          l0_stag = ii_stag*dx(i0) - xpnew0(i0) + left_edge(i0)
          delta0_stag = abs(l0_stag/dx(i0))
          if (delta0_stag .lt. 0.5d0) then
            w0_stag = w0_stag + 0.75d0 - delta0_stag**2.d0
          else if (delta0_stag .lt. 1.5d0) then
            w0_stag = w0_stag + 0.5d0 * (1.5d0 - delta0_stag)**2.d0
          endif
          w0_stag = half*w0_stag

          weight = w0_stag*(1.0 - delta1)*seg_factor(i1)
          Epy = Epy + weight*Ey(CHF_IX[ii_stag;jj;kk]) 
        
          weight = w0_stag*delta1*seg_factor(i1)
          Epy = Epy + weight*Ey(CHF_IX[ii_stag;jj+1;kk])

        enddo

c     update xpold
        xpold0 = xpnew0
            
      enddo

c
c     cloud in cell for Ez, Bx, By, and Bz
c

      do idir = 0, CH_SPACEDIM - 1
        index(idir) = floor((xphalf(idir) - left_edge(idir) - 0.5d0*dx(idir)) / dx(idir))
        index_stag(idir) = floor((xphalf(idir) - left_edge(idir)) / dx(idir))
      enddo

      CHF_DTERM[
      do ii = index(0), index(0) + 1
        l0 = ii*dx(0) + 0.5d0*dx(0) - xphalf(0) + left_edge(0)
        ii_stag = ii-index(0)+index_stag(0)
        l0_stag = ii_stag*dx(0) - xphalf(0) + left_edge(0)
        w0 = 1.d0 - abs(l0 / dx(0))
        w0_stag = 1.d0 - abs(l0_stag / dx(0));
        do jj = index(1), index(1) + 1
          l1 = jj*dx(1) + 0.5d0*dx(1) - xphalf(1) + left_edge(1)
          jj_stag = jj-index(1)+index_stag(1)
          l1_stag = jj_stag*dx(1) - xphalf(1) + left_edge(1)
          w1 = 1.d0 - abs(l1 / dx(1))
          w1_stag = 1.d0 - abs(l1_stag / dx(1));
          do kk = index(2), index(2) + 1
            l2 = kk*dx(2) + 0.5d0*dx(2) - xphalf(2) + left_edge(2)
            kk_stag = kk-index(2)+index_stag(2)
            l2_stag = kk_stag*dx(2) - xphalf(2) + left_edge(2)
            w2 = 1.d0 - abs(l2 / dx(2))
            w2_stag = 1.d0 - abs(l2_stag / dx(2)) ]

            weight = CHF_DTERM[w0_stag; *w1_stag; *w2]
            Epz = Epz + weight*Ez(CHF_IX[ii_stag; jj_stag; kk])

            weight = CHF_DTERM[w0_stag; *w1; *w2]
            Bpx = Bpx + weight*Bx(CHF_IX[ii_stag; jj; kk])
            
            weight = CHF_DTERM[w0; *w1_stag; *w2]
            Bpy = Bpy + weight*By(CHF_IX[ii; jj_stag; kk])
            
            weight = CHF_DTERM[w0; *w1; *w2_stag]
            Bpz = Bpz + weight*Bz(CHF_IX[ii; jj; kk_stag])

      CHF_DTERM[
          enddo;
        enddo;
      enddo]

      end

