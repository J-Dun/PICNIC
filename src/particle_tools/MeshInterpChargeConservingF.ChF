
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c  Charge-conserving deposit for particle current density using a combination
c  of NGP and CIC interpolation with cell crossings included
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine cc0_1d_deposit_current(
     &                       CHF_FRA1[rhoVx],
     &                       CHF_FRA1[rhoVy],
     &                       CHF_FRA1[rhoVz],
     &                       CHF_CONST_INTVECT[bc_check_left],
     &                       CHF_CONST_INTVECT[bc_check_right],
     &                       CHF_CONST_REALVECT[left_edge],
     &                       CHF_CONST_REALVECT[right_edge],
     &                       CHF_CONST_REALVECT[dx],
     &                       CHF_CONST_REALVECT[xpold_save],
     &                       CHF_CONST_REALVECT[xpbar],
     &                       CHF_CONST_REAL[vpx], 
     &                       CHF_CONST_REAL[vpy], 
     &                       CHF_CONST_REAL[vpz], 
     &                       CHF_CONST_REAL[dt], 
     &                       CHF_CONST_REAL[qp]) 

      integer index_stag(0:CH_SPACEDIM - 1)
      integer index_stag_old(0:CH_SPACEDIM - 1), index_stag_new(0:CH_SPACEDIM - 1)
      integer cell_crossings(0:CH_SPACEDIM - 1), idir, num_segments
      REAL_T CHF_DDECL[l0;l1;l2], CHF_DDECL[w0;w1;w2]
      REAL_T dXp(0:CH_SPACEDIM - 1), dXp_sub(0:CH_SPACEDIM - 1) 
      REAL_T xpold(0:CH_SPACEDIM - 1), xpnew(0:CH_SPACEDIM - 1)
      REAL_T xpold0(0:CH_SPACEDIM - 1), xpnew0(0:CH_SPACEDIM - 1) 
      REAL_T Xcell(0:CH_SPACEDIM - 1)
      REAL_T volume, rhop, weight, seg_factor
      integer nn, sign(0:CH_SPACEDIM - 1), i0
      integer ii, jj, kk, ii_next, jj_next, kk_next 

c     compute the cell volume and particle density on the grid
      volume = CHF_DTERM[dx(0);*dx(1);*dx(2)]
      rhop = qp / volume

c     xpold can change, don't change the one passed in
      xpold = xpold_save

c     compute the new particle position
      do idir = 0, CH_SPACEDIM - 1
        xpnew(idir) = two*xpbar(idir) - xpold(idir)
        dXp(idir) = xpnew(idir) - xpold(idir)
        sign(idir) = 1
      enddo
     
      i0 = 0

c     do this after setting dXp    
      if( bc_check_left(i0)==1 ) then
        if(xpold(i0)<left_edge(i0)) then
          xpold(i0) = left_edge(i0)
        endif
        if(xpnew(i0)<left_edge(i0)) then
          xpnew(i0) = left_edge(i0)
        endif
      endif
      if( bc_check_right(i0)==1 ) then
        if(xpold(i0)>right_edge(i0)) then
          xpold(i0) = right_edge(i0)
        endif
        if(xpnew(i0)>right_edge(i0)) then
          xpnew(i0) = right_edge(i0)
        endif
      endif

c     compute the index of the left most cell/edge that contains this particle cloud
      num_segments = 1
      do idir = 0, CH_SPACEDIM - 1
        index_stag_old(idir) = floor((xpold(idir) - left_edge(idir)) / dx(idir))
        index_stag_new(idir) = floor((xpnew(idir)  - left_edge(idir)) / dx(idir))
        if(index_stag_new(idir)<index_stag_old(idir)) then
          sign(idir) = -1
        endif
        cell_crossings(idir) = ABS(index_stag_new(idir) - index_stag_old(idir))
        num_segments = num_segments + cell_crossings(idir)
      enddo

c     calculate the initial Xcell in each direction
      do idir = 0, CH_SPACEDIM -1
        Xcell(idir) = left_edge(idir) + (index_stag_old(idir) + half*(1-sign(idir)))*dx(idir)
      enddo

      xpold0 = xpold
      CHF_DTERM[ii_next=index_stag_old(0); 
                jj_next=index_stag_old(1); 
                kk_next=index_stag_old(2)]

      do nn=0, num_segments-1

        CHF_DTERM[ii=ii_next; 
                  jj=jj_next; 
                  kk=kk_next]

        if(nn==num_segments-1) then
          xpnew0 = xpnew
          dXp_sub = xpnew0 - xpold0
        else
          ii_next = ii + sign(i0)
          Xcell(i0) = Xcell(i0) + sign(i0)*dx(i0)
          xpnew0(i0) = Xcell(i0)
          dXp_sub(i0) = xpnew0(i0) - xpold0(i0)
        endif

c     deposit the particle x-current to the grid
        if( dXp(i0).ne.zero ) then
          seg_factor = dXp_sub(i0)/dXp(i0)
        else
          seg_factor = 1.d0
        endif

        weight = seg_factor
        rhoVx(CHF_IX[ii; jj; kk]) = 
     &  rhoVx(CHF_IX[ii; jj; kk]) + vpx * rhop * weight
c     &  rhoVx(CHF_IX[ii; jj; kk]) + dXp(i0)/dt * rhop * weight
        
c     update xpold
        xpold0 = xpnew0
            
      enddo

c
c     deposit the particle y an z current to the grid
c

      do idir = 0, CH_SPACEDIM - 1
        index_stag(idir) = floor((xpbar(idir) - left_edge(idir)) / dx(idir))
      enddo

      CHF_DTERM[
      do ii = index_stag(0), index_stag(0) + 1
        l0 = ii*dx(0) - xpbar(0) + left_edge(0)
        w0 = 1.d0 - abs(l0/dx(0));
        do jj = index_stag(1), index_stag(1) + 1
          l1 = jj*dx(1) - xpbar(1) + left_edge(1)
          w1 = 1.d0;
          do kk = 1, 2
            l2 = 0
            w2 = 1.d0 ]

            weight = CHF_DTERM[w0; *w1; *w2]
            rhoVy(CHF_IX[ii; jj; kk]) = 
     &      rhoVy(CHF_IX[ii; jj; kk]) + vpy * rhop * weight

            rhoVz(CHF_IX[ii; jj; kk]) = 
     &      rhoVz(CHF_IX[ii; jj; kk]) + vpz * rhop * weight

      CHF_DTERM[
          enddo;
        enddo;
      enddo]

      end

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c  Charge-conserving deposit for particle current density using a combination
c  of NGP and CIC interpolation with cell crossings included
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine cc0_2d_deposit_current(
     &                       CHF_FRA1[rhoVx],
     &                       CHF_FRA1[rhoVy],
     &                       CHF_FRA1[rhoVz],
     &                       CHF_CONST_INTVECT[bc_check_left],
     &                       CHF_CONST_INTVECT[bc_check_right],
     &                       CHF_CONST_REALVECT[left_edge],
     &                       CHF_CONST_REALVECT[right_edge],
     &                       CHF_CONST_REALVECT[dx],
     &                       CHF_CONST_REALVECT[xpold_save],
     &                       CHF_CONST_REALVECT[xpbar],
     &                       CHF_CONST_REAL[vpx], 
     &                       CHF_CONST_REAL[vpy], 
     &                       CHF_CONST_REAL[vpz], 
     &                       CHF_CONST_REAL[dt], 
     &                       CHF_CONST_REAL[qp]) 

      integer index_stag(0:CH_SPACEDIM - 1)
      integer index_stag_old(0:CH_SPACEDIM - 1), index_stag_new(0:CH_SPACEDIM - 1)
      integer cell_crossings(0:CH_SPACEDIM - 1), idir, num_segments

      REAL_T CHF_DDECL[l0;l1;l2], CHF_DDECL[w0;w1;w2]
      REAL_T dXp(0:CH_SPACEDIM - 1), dXp_sub(0:CH_SPACEDIM - 1) 
      REAL_T xpold(0:CH_SPACEDIM - 1), xpnew(0:CH_SPACEDIM - 1)
      REAL_T xpold0(0:CH_SPACEDIM - 1), xpnew0(0:CH_SPACEDIM - 1)
      REAL_T Xcell(0:CH_SPACEDIM - 1)
      REAL_T volume, rhop, weight, slope, slope_inv, dXp_sub02
      integer nn, sign(0:CH_SPACEDIM - 1), i0, i1
      integer ii, jj, kk, ii_next, jj_next, kk_next 

c     compute the cell volume and particle density on the grid
      volume = CHF_DTERM[dx(0);*dx(1);*dx(2)]
      rhop = qp / volume

c     xpold can change, don't change the one passed in
      xpold = xpold_save

c     compute the new particle position
      do idir = 0, CH_SPACEDIM - 1
        xpnew(idir) = two*xpbar(idir) - xpold(idir)
        dXp(idir) = xpnew(idir) - xpold(idir)
        sign(idir) = 1
      enddo
     
c     compute slopes assuming 2D
      i0 = 0
      i1 = CH_SPACEDIM-1
      slope = dXp(i1)/dXp(i0)
      slope_inv = 1/slope

c     do check for bc particles after setting dXp  
      call truncate_boundaries( xpold, xpnew,
     &                          bc_check_left, bc_check_right,
     &                          left_edge, right_edge,
     &                          slope, slope_inv )

c     compute the index of the left most cell/edge that contains this particle cloud
      num_segments = 1
      do idir = 0, CH_SPACEDIM - 1
        index_stag_old(idir) = floor((xpold(idir) - left_edge(idir)) / dx(idir))
        index_stag_new(idir) = floor((xpnew(idir) - left_edge(idir)) / dx(idir))
        if(index_stag_new(idir)<index_stag_old(idir)) then
          sign(idir) = -1
        endif
        cell_crossings(idir) = ABS(index_stag_new(idir) - index_stag_old(idir))
        num_segments = num_segments + cell_crossings(idir)
      enddo

c     calculate the initial Xcell in each direction
      do idir = 0, CH_SPACEDIM -1
        Xcell(idir) = left_edge(idir) + (index_stag_old(idir) + half*(1-sign(idir)))*dx(idir)
      enddo

      CHF_DTERM[ii_next=index_stag_old(0); 
                jj_next=index_stag_old(1); 
                kk_next=index_stag_old(2)]

      xpold0 = xpold
      do nn=0, num_segments-1

        CHF_DTERM[ii=ii_next; 
                  jj=jj_next; 
                  kk=kk_next]

        if(nn==num_segments-1) then
          xpnew0 = xpnew
          dXp_sub = xpnew0 - xpold0
        else if(cell_crossings(i0)==0) then
          jj_next = jj + sign(i1)
          Xcell(i1) = Xcell(i1) + sign(i1)*dx(i1)
          xpnew0(i1) = Xcell(i1)
          dXp_sub(i1) = xpnew0(i1) - xpold0(i1)
          dXp_sub(i0) = slope_inv*dXp_sub(i1)
          xpnew0(i0) = xpold0(i0) + dXp_sub(i0)
        else if(cell_crossings(i1)==0) then
          ii_next = ii + sign(i0)
          Xcell(i0) = Xcell(i0) + sign(i0)*dx(i0)
          xpnew0(i0) = Xcell(i0)
          dXp_sub(i0) = xpnew0(i0) - xpold0(i0)
          dXp_sub(i1) = slope*dXp_sub(i0)
          xpnew0(i1) = xpold0(i1) + dXp_sub(i1)
        else
          xpnew0(i0) = Xcell(i0) + sign(i0)*dx(i0)
          xpnew0(i1) = Xcell(i1) + sign(i1)*dx(i1)
          dXp_sub(i0) = xpnew0(i0) - xpold0(i0)
          dXp_sub(i1) = xpnew0(i1) - xpold0(i1)
          dXp_sub02 = slope_inv*dXp_sub(i1)

          if(abs(dXp_sub(i0))<abs(dXp_sub02)) then
            dXp_sub(i1) = slope*dXp_sub(i0)
            xpnew0(i1) = xpold0(i1) + dXp_sub(i1)
            Xcell(i0) = xpnew0(i0)
            ii_next = ii + sign(i0)
            cell_crossings(i0) = cell_crossings(i0) - 1
          else
            dXp_sub(i0) = slope_inv*dXp_sub(i1)
            xpnew0(i0) = xpold0(i0) + dXp_sub(i0)
            Xcell(i1) = xpnew0(i1)
            jj_next = jj + sign(i1)
            cell_crossings(i1) = cell_crossings(i1) - 1
          endif

        endif

        CHF_DTERM[l0 = half*(xpold0(0)+xpnew0(0)) - (left_edge(0) + ii*dx(0));
                  l1 = half*(xpold0(1)+xpnew0(1)) - (left_edge(1) + jj*dx(1));
                  l2 = half*(xpold0(2)+xpnew0(2)) - (left_edge(2) + kk*dx(2))]

c     deposit the particle x-current to the grid
        CHF_DTERM[
        if(dXp(i0).eq.0.0) then
          w0 = 1.0
        else
          w0 = dXp_sub(i0)/dXp(i0)
        endif;
        w1 = 1.d0 - l1/dx(1);
        w2 = 0.0]

        weight = CHF_DTERM[w0; *w1; *w2]
        rhoVx(CHF_IX[ii; jj; kk]) = 
     &  rhoVx(CHF_IX[ii; jj; kk]) + vpx * rhop * weight
c     &  rhoVx(CHF_IX[ii; jj; kk]) + dXp(i0)/dt * rhop * weight
        
        weight = CHF_DTERM[w0; *(1.d0-w1); *w2]
        rhoVx(CHF_IX[ii; jj+1; kk]) = 
     &  rhoVx(CHF_IX[ii; jj+1; kk]) + vpx * rhop * weight
c     &  rhoVx(CHF_IX[ii; jj+1; kk]) + dXp(i0)/dt * rhop * weight

c     deposit the particle y-current to the grid
        CHF_DTERM[
        w0 = 1.d0 - l0/dx(0);
        if(dXp(i1).eq.0.0) then
          w1 = 1.0
        else
          w1 = dXp_sub(i1)/dXp(i1)
        endif;
        w2 = 0.0]

        weight = CHF_DTERM[w0; *w1; *w2]
        rhoVy(CHF_IX[ii; jj; kk]) = 
     &  rhoVy(CHF_IX[ii; jj; kk]) + vpy * rhop * weight
c     &  rhoVy(CHF_IX[ii; jj; kk]) + dXp(i1)/dt * rhop * weight
        
        weight = CHF_DTERM[(1.d0-w0); *w1; *w2]
        rhoVy(CHF_IX[ii+1; jj; kk]) = 
     &  rhoVy(CHF_IX[ii+1; jj; kk]) + vpy * rhop * weight
c     &  rhoVy(CHF_IX[ii+1; jj; kk]) + dXp(i1)/dt * rhop * weight

c     update xpold
        xpold0 = xpnew0
            
      enddo

c
c     deposit the particle z-current to the grid
c

      do idir = 0, CH_SPACEDIM - 1
        index_stag(idir) = floor((xpbar(idir) - left_edge(idir)) / dx(idir))
      enddo

      CHF_DTERM[
      do ii = index_stag(0), index_stag(0) + 1
        l0 = ii*dx(0) - xpbar(0) + left_edge(0)
        w0 = 1.d0 - abs(l0/dx(0));
        do jj = index_stag(1), index_stag(1) + 1
          l1 = jj*dx(1) - xpbar(1) + left_edge(1)
          w1 = 1.d0 - abs(l1/dx(1));
          do kk = 1,2
            l2 = 0
            w2 = 1.d0 ]

            weight = CHF_DTERM[w0; *w1; *w2]
            rhoVz(CHF_IX[ii; jj; kk]) = 
     &      rhoVz(CHF_IX[ii; jj; kk]) + vpz * rhop * weight

      CHF_DTERM[
          enddo;
        enddo;
      enddo]

      end

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c  Charge-conserving interpolation of fields to particles using a combination
c  of NGP and CIC interpolation with cell crossings included (needed for energy conservation)
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine cc0_1d_interpolate_fields( CHF_REAL[Epx],
     &                                   CHF_REAL[Epy],
     &                                   CHF_REAL[Epz],
     &                                   CHF_REAL[Bpx],
     &                                   CHF_REAL[Bpy],
     &                                   CHF_REAL[Bpz],
     &                                   CHF_CONST_FRA1[Ex],
     &                                   CHF_CONST_FRA1[Ey],
     &                                   CHF_CONST_FRA1[Ez],
     &                                   CHF_CONST_FRA1[Bx],
     &                                   CHF_CONST_FRA1[By],
     &                                   CHF_CONST_FRA1[Bz],
     &                                   CHF_CONST_INTVECT[bc_check_left],
     &                                   CHF_CONST_INTVECT[bc_check_right],
     &                                   CHF_CONST_REALVECT[left_edge],
     &                                   CHF_CONST_REALVECT[right_edge],
     &                                   CHF_CONST_REALVECT[dx],
     &                                   CHF_CONST_REALVECT[xpold_save],
     &                                   CHF_CONST_REALVECT[xpbar] )

      integer CHF_DDECL[ii_stag;jj_stag;kk_stag]
      REAL_T CHF_DDECL[l0_stag;l1_stag;l2_stag]
      REAL_T CHF_DDECL[w0_stag;w1_stag;w2_stag]
      
      integer index(0:CH_SPACEDIM - 1), index_stag(0:CH_SPACEDIM - 1)
      integer index_stag_old(0:CH_SPACEDIM - 1), index_stag_new(0:CH_SPACEDIM - 1)
      integer cell_crossings(0:CH_SPACEDIM - 1), idir, num_segments
      REAL_T CHF_DDECL[l0;l1;l2], CHF_DDECL[w0;w1;w2]
      REAL_T dXp(0:CH_SPACEDIM - 1), dXp_sub(0:CH_SPACEDIM - 1) 
      REAL_T xpold(0:CH_SPACEDIM - 1), xpnew(0:CH_SPACEDIM - 1)
      REAL_T xpold0(0:CH_SPACEDIM - 1), xpnew0(0:CH_SPACEDIM - 1) 
      REAL_T Xcell(0:CH_SPACEDIM - 1)
      REAL_T weight, seg_factor
      integer nn, sign(0:CH_SPACEDIM - 1), i0
      integer ii, jj, kk, ii_next, jj_next, kk_next 

c     xpold can change, don't change the one passed in
      xpold = xpold_save

c     compute the new particle position
      do idir = 0, CH_SPACEDIM - 1
        xpnew(idir) = two*xpbar(idir) - xpold(idir)
        dXp(idir) = xpnew(idir) - xpold(idir)
        sign(idir) = 1
      enddo
     
      i0 = 0

c     do this after setting dXp    
      if( bc_check_left(i0)==1 ) then
        if(xpold(i0)<left_edge(i0)) then
          xpold(i0) = left_edge(i0)
        endif
        if(xpnew(i0)<left_edge(i0)) then
          xpnew(i0) = left_edge(i0)
        endif
      endif
      if( bc_check_right(i0)==1 ) then
        if(xpold(i0)>right_edge(i0)) then
          xpold(i0) = right_edge(i0)
        endif
        if(xpnew(i0)>right_edge(i0)) then
          xpnew(i0) = right_edge(i0)
        endif
      endif

c     compute the index of the left most cell/edge that contains this particle cloud
      num_segments = 1
      do idir = 0, CH_SPACEDIM - 1
        index_stag_old(idir) = floor((xpold(idir) - left_edge(idir)) / dx(idir))
        index_stag_new(idir) = floor((xpnew(idir)  - left_edge(idir)) / dx(idir))
        if(index_stag_new(idir)<index_stag_old(idir)) then
          sign(idir) = -1
        endif
        cell_crossings(idir) = ABS(index_stag_new(idir) - index_stag_old(idir))
        num_segments = num_segments + cell_crossings(idir)
      enddo

c     calculate the initial Xcell in each direction
      do idir = 0, CH_SPACEDIM -1
        Xcell(idir) = left_edge(idir) + (index_stag_old(idir) + half*(1-sign(idir)))*dx(idir)
      enddo

      CHF_DTERM[ii_next=index_stag_old(0); 
                jj_next=index_stag_old(1); 
                kk_next=index_stag_old(2)]

      xpold0 = xpold
      do nn=0, num_segments-1

        CHF_DTERM[ii=ii_next; 
                  jj=jj_next; 
                  kk=kk_next]

        if(nn==num_segments-1) then
          xpnew0 = xpnew
          dXp_sub = xpnew0 - xpold0
        else
          ii_next = ii + sign(i0)
          Xcell(i0) = Xcell(i0) + sign(i0)*dx(i0)
          xpnew0(i0) = Xcell(i0)
          dXp_sub(i0) = xpnew0(i0) - xpold0(i0)
        endif

c     interpolate Ex to particle
        if( dXp(i0).ne.zero ) then
          seg_factor = dXp_sub(i0)/dXp(i0)
        else
          seg_factor = 1.d0
        endif

        weight = seg_factor
        Epx = Epx + weight*Ex(CHF_IX[ii;jj;kk]) 
        
c     update xpold
        xpold0 = xpnew0
            
      enddo

c
c     cloud in cell for Ey, Ez, Bx, By, and Bz
c

      do idir = 0, CH_SPACEDIM - 1
        index(idir) = floor((xpbar(idir) - left_edge(idir) - 0.5d0*dx(idir)) / dx(idir))
        index_stag(idir) = floor((xpbar(idir) - left_edge(idir)) / dx(idir))
      enddo

      CHF_DTERM[
      do ii = index(0), index(0) + 1
        l0 = ii*dx(0) + 0.5d0*dx(0) - xpbar(0) + left_edge(0)
        ii_stag = ii-index(0)+index_stag(0)
        l0_stag = ii_stag*dx(0) - xpbar(0) + left_edge(0)
        w0 = 1.d0 - abs(l0 / dx(0))
        w0_stag = 1.d0 - abs(l0_stag / dx(0));
        do jj = index(1), index(1) + 1
          l1 = jj*dx(1) + 0.5d0*dx(1) - xpbar(1) + left_edge(1)
          jj_stag = jj-index(1)+index_stag(1)
          l1_stag = jj_stag*dx(1) - xpbar(1) + left_edge(1)
          w1 = 1.d0 - abs(l1 / dx(1))
          w1_stag = 1.d0 - abs(l1_stag / dx(1));
          do kk = index(2), index(2) + 1
            l2 = kk*dx(2) + 0.5d0*dx(2) - xpbar(2) + left_edge(2)
            kk_stag = kk-index(2)+index_stag(2)
            l2_stag = kk_stag*dx(2) - xpbar(2) + left_edge(2)
            w2 = 1.d0 - abs(l2 / dx(2))
            w2_stag = 1.d0 - abs(l2_stag / dx(2)) ]
            
            weight = CHF_DTERM[w0_stag; *w1; *w2_stag]
            Epy = Epy + weight*Ey(CHF_IX[ii_stag; jj; kk_stag])

            weight = CHF_DTERM[w0_stag; *w1_stag; *w2]
            Epz = Epz + weight*Ez(CHF_IX[ii_stag; jj_stag; kk])

            weight = CHF_DTERM[w0_stag; *w1; *w2]
            Bpx = Bpx + weight*Bx(CHF_IX[ii_stag; jj; kk])
            
            weight = CHF_DTERM[w0; *w1_stag; *w2]
            Bpy = Bpy + weight*By(CHF_IX[ii; jj_stag; kk])
            
            weight = CHF_DTERM[w0; *w1; *w2_stag]
            Bpz = Bpz + weight*Bz(CHF_IX[ii; jj; kk_stag])

      CHF_DTERM[
          enddo;
        enddo;
      enddo]

      end

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c  Charge-conserving interpolation of fields to particles using a combination
c  of NGP and CIC interpolation with cell crossings included (needed for energy conservation)
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine cc0_2d_interpolate_fields( CHF_REAL[Epx],
     &                                   CHF_REAL[Epy],
     &                                   CHF_REAL[Epz],
     &                                   CHF_REAL[Bpx],
     &                                   CHF_REAL[Bpy],
     &                                   CHF_REAL[Bpz],
     &                                   CHF_CONST_FRA1[Ex],
     &                                   CHF_CONST_FRA1[Ey],
     &                                   CHF_CONST_FRA1[Ez],
     &                                   CHF_CONST_FRA1[Bx],
     &                                   CHF_CONST_FRA1[By],
     &                                   CHF_CONST_FRA1[Bz],
     &                                   CHF_CONST_INTVECT[bc_check_left],
     &                                   CHF_CONST_INTVECT[bc_check_right],
     &                                   CHF_CONST_REALVECT[left_edge],
     &                                   CHF_CONST_REALVECT[right_edge],
     &                                   CHF_CONST_REALVECT[dx],
     &                                   CHF_CONST_REALVECT[xpold_save],
     &                                   CHF_CONST_REALVECT[xpbar] )

      integer CHF_DDECL[ii_stag;jj_stag;kk_stag]
      REAL_T CHF_DDECL[l0_stag;l1_stag;l2_stag]
      REAL_T CHF_DDECL[w0_stag;w1_stag;w2_stag]
      integer index(0:CH_SPACEDIM - 1), index_stag(0:CH_SPACEDIM - 1)
      
      integer index_stag_old(0:CH_SPACEDIM - 1), index_stag_new(0:CH_SPACEDIM - 1)
      integer cell_crossings(0:CH_SPACEDIM - 1), idir, num_segments
      REAL_T CHF_DDECL[l0;l1;l2], CHF_DDECL[w0;w1;w2]
      REAL_T dXp(0:CH_SPACEDIM - 1), dXp_sub(0:CH_SPACEDIM - 1)
      REAL_T xpold(0:CH_SPACEDIM - 1), xpnew(0:CH_SPACEDIM - 1)
      REAL_T xpold0(0:CH_SPACEDIM - 1), xpnew0(0:CH_SPACEDIM - 1)
      REAL_T Xcell(0:CH_SPACEDIM - 1)
      REAL_T weight, slope, slope_inv, dXp_sub02
      integer nn, sign(0:CH_SPACEDIM - 1), i0, i1
      integer ii, jj, kk, ii_next, jj_next, kk_next 

c     xpold can change, don't change the one passed in
      xpold = xpold_save

c     compute the new particle position
      do idir = 0, CH_SPACEDIM - 1
        xpnew(idir) = two*xpbar(idir) - xpold(idir)
        dXp(idir) = xpnew(idir) - xpold(idir)
        sign(idir) = 1
      enddo
     
c     compute slopes assuming 2D
      i0 = 0
      i1 = CH_SPACEDIM-1
      slope = dXp(i1)/dXp(i0)
      slope_inv = 1/slope

c     do check for bc particles after setting dXp  
      call truncate_boundaries( xpold, xpnew,
     &                          bc_check_left, bc_check_right,
     &                          left_edge, right_edge,
     &                          slope, slope_inv )

c     compute the index of the left most cell/edge that contains this particle cloud
      num_segments = 1
      do idir = 0, CH_SPACEDIM - 1
        index_stag_old(idir) = floor((xpold(idir) - left_edge(idir)) / dx(idir))
        index_stag_new(idir) = floor((xpnew(idir) - left_edge(idir)) / dx(idir))
        if(index_stag_new(idir)<index_stag_old(idir)) then
          sign(idir) = -1
        endif
        cell_crossings(idir) = ABS(index_stag_new(idir) - index_stag_old(idir))
        num_segments = num_segments + cell_crossings(idir)
      enddo

c     calculate the initial Xcell in each direction
      do idir = 0, CH_SPACEDIM -1
        Xcell(idir) = left_edge(idir) + (index_stag_old(idir) + half*(1-sign(idir)))*dx(idir)
      enddo

      CHF_DTERM[ii_next=index_stag_old(0); 
                jj_next=index_stag_old(1); 
                kk_next=index_stag_old(2)]

      xpold0 = xpold
      do nn=0, num_segments-1

        CHF_DTERM[ii=ii_next; 
                  jj=jj_next; 
                  kk=kk_next]

        if(nn==num_segments-1) then
          xpnew0 = xpnew
          dXp_sub = xpnew0 - xpold0
        else if(cell_crossings(i0)==0) then
          jj_next = jj + sign(i1)
          Xcell(i1) = Xcell(i1) + sign(i1)*dx(i1)
          xpnew0(i1) = Xcell(i1)
          dXp_sub(i1) = xpnew0(i1) - xpold0(i1)
          dXp_sub(i0) = slope_inv*dXp_sub(i1)
          xpnew0(i0) = xpold0(i0) + dXp_sub(i0)
        else if(cell_crossings(i1)==0) then
          ii_next = ii + sign(i0)
          Xcell(i0) = Xcell(i0) + sign(i0)*dx(i0)
          xpnew0(i0) = Xcell(i0)
          dXp_sub(i0) = xpnew0(i0) - xpold0(i0)
          dXp_sub(i1) = slope*dXp_sub(i0)
          xpnew0(i1) = xpold0(i1) + dXp_sub(i1)
        else
          xpnew0(i0) = Xcell(i0) + sign(i0)*dx(i0)
          xpnew0(i1) = Xcell(i1) + sign(i1)*dx(i1)
          dXp_sub(i0) = xpnew0(i0) - xpold0(i0)
          dXp_sub(i1) = xpnew0(i1) - xpold0(i1)
          dXp_sub02 = slope_inv*dXp_sub(i1)

          if(abs(dXp_sub(i0))<abs(dXp_sub02)) then
            dXp_sub(i1) = slope*dXp_sub(i0)
            xpnew0(i1) = xpold0(i1) + dXp_sub(i1)
            Xcell(i0) = xpnew0(i0)
            ii_next = ii + sign(i0)
            cell_crossings(i0) = cell_crossings(i0) - 1
          else
            dXp_sub(i0) = slope_inv*dXp_sub(i1)
            xpnew0(i0) = xpold0(i0) + dXp_sub(i0)
            Xcell(i1) = xpnew0(i1)
            jj_next = jj + sign(i1)
            cell_crossings(i1) = cell_crossings(i1) - 1
          endif

        endif

        CHF_DTERM[l0 = half*(xpold0(0)+xpnew0(0)) - (left_edge(0) + ii*dx(0));
                  l1 = half*(xpold0(1)+xpnew0(1)) - (left_edge(1) + jj*dx(1));
                  l2 = half*(xpold0(2)+xpnew0(2)) - (left_edge(2) + kk*dx(2))]

c     interpolate Ex to particle
        CHF_DTERM[
        if(dXp(i0).eq.0.0) then
          w0 = 1.0
        else
          w0 = dXp_sub(i0)/dXp(i0)
        endif;
        w1 = 1.d0 - l1/dx(1);
        w2 = 0.0]

        weight = CHF_DTERM[w0; *w1; *w2]
        Epx = Epx + weight*Ex(CHF_IX[ii;jj;kk]) 
        
        weight = CHF_DTERM[w0; *(1.d0-w1); *w2]
        Epx = Epx + weight*Ex(CHF_IX[ii;jj+1;kk])

c     interpolate Ey to particle
        CHF_DTERM[
        w0 = 1.d0 - l0/dx(0);
        if(dXp(i1).eq.0.0) then
          w1 = 1.0
        else
          w1 = dXp_sub(i1)/dXp(i1)
        endif;
        w2 = 0.0]
        
        weight = CHF_DTERM[w0; *w1; *w2]
        Epy = Epy + weight*Ey(CHF_IX[ii;jj;kk]) 
        
        weight = CHF_DTERM[(1.d0-w0); *w1; *w2]
        Epy = Epy + weight*Ey(CHF_IX[ii+1;jj;kk])

c     update xpold
        xpold0 = xpnew0
            
      enddo

c
c     cloud in cell for Ez, Bx, By, and Bz
c

      do idir = 0, CH_SPACEDIM - 1
        index(idir) = floor((xpbar(idir) - left_edge(idir) - 0.5d0*dx(idir)) / dx(idir))
        index_stag(idir) = floor((xpbar(idir) - left_edge(idir)) / dx(idir))
      enddo

      CHF_DTERM[
      do ii = index(0), index(0) + 1
        l0 = ii*dx(0) + 0.5d0*dx(0) - xpbar(0) + left_edge(0)
        ii_stag = ii-index(0)+index_stag(0)
        l0_stag = ii_stag*dx(0) - xpbar(0) + left_edge(0)
        w0 = 1.d0 - abs(l0 / dx(0))
        w0_stag = 1.d0 - abs(l0_stag / dx(0));
        do jj = index(1), index(1) + 1
          l1 = jj*dx(1) + 0.5d0*dx(1) - xpbar(1) + left_edge(1)
          jj_stag = jj-index(1)+index_stag(1)
          l1_stag = jj_stag*dx(1) - xpbar(1) + left_edge(1)
          w1 = 1.d0 - abs(l1 / dx(1))
          w1_stag = 1.d0 - abs(l1_stag / dx(1));
          do kk = index(2), index(2) + 1
            l2 = kk*dx(2) + 0.5d0*dx(2) - xpbar(2) + left_edge(2)
            kk_stag = kk-index(2)+index_stag(2)
            l2_stag = kk_stag*dx(2) - xpbar(2) + left_edge(2)
            w2 = 1.d0 - abs(l2 / dx(2))
            w2_stag = 1.d0 - abs(l2_stag / dx(2)) ]

            weight = CHF_DTERM[w0_stag; *w1_stag; *w2]
            Epz = Epz + weight*Ez(CHF_IX[ii_stag; jj_stag; kk])

            weight = CHF_DTERM[w0_stag; *w1; *w2]
            Bpx = Bpx + weight*Bx(CHF_IX[ii_stag; jj; kk])
            
            weight = CHF_DTERM[w0; *w1_stag; *w2]
            Bpy = Bpy + weight*By(CHF_IX[ii; jj_stag; kk])
            
            weight = CHF_DTERM[w0; *w1; *w2_stag]
            Bpz = Bpz + weight*Bz(CHF_IX[ii; jj; kk_stag])

      CHF_DTERM[
          enddo;
        enddo;
      enddo]

      end

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c  derivative of fields wrt y = xpnew - xpold for 1D CC0 interpolation scheme
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine cc0_1d_field_derivatives( CHF_REALVECT[dEpx],
     &                                     CHF_REALVECT[dEpy],
     &                                     CHF_REALVECT[dEpz],
     &                                     CHF_REALVECT[dBpx],
     &                                     CHF_REALVECT[dBpy],
     &                                     CHF_REALVECT[dBpz],
     &                                     CHF_CONST_FRA1[Ex],
     &                                     CHF_CONST_FRA1[Ey],
     &                                     CHF_CONST_FRA1[Ez],
     &                                     CHF_CONST_FRA1[Bx],
     &                                     CHF_CONST_FRA1[By],
     &                                     CHF_CONST_FRA1[Bz],
     &                                     CHF_CONST_INTVECT[bc_check_left],
     &                                     CHF_CONST_INTVECT[bc_check_right],
     &                                     CHF_CONST_REALVECT[left_edge],
     &                                     CHF_CONST_REALVECT[right_edge],
     &                                     CHF_CONST_REALVECT[dx],
     &                                     CHF_CONST_REALVECT[xpold_save],
     &                                     CHF_CONST_REALVECT[xpbar] )

      integer CHF_DDECL[ii_stag;jj_stag;kk_stag]
      REAL_T CHF_DDECL[l0_stag;l1_stag;l2_stag]
      REAL_T CHF_DDECL[w0_stag;w1_stag;w2_stag]
      REAL_T Epx, wup, wdn

      integer index(0:CH_SPACEDIM - 1), index_stag(0:CH_SPACEDIM - 1)
      integer index_stag_old(0:CH_SPACEDIM - 1), index_stag_new(0:CH_SPACEDIM - 1)
      integer cell_crossings(0:CH_SPACEDIM - 1), idir, num_segments
      REAL_T CHF_DDECL[l0;l1;l2], CHF_DDECL[w0;w1;w2]
      REAL_T dXp(0:CH_SPACEDIM - 1), dXp_sub(0:CH_SPACEDIM - 1) 
      REAL_T xpold(0:CH_SPACEDIM - 1), xpnew(0:CH_SPACEDIM - 1)
      REAL_T xpold0(0:CH_SPACEDIM - 1), xpnew0(0:CH_SPACEDIM - 1) 
      REAL_T Xcell(0:CH_SPACEDIM - 1), xpbar0(0:CH_SPACEDIM - 1)
      REAL_T weight, dXp_sub02, seg_factor
      integer nn, sign(0:CH_SPACEDIM - 1), i0
      integer ii, jj, kk, ii_next, jj_next, kk_next 
      integer bc_particle

c     compute the new particle position
      do idir = 0, CH_SPACEDIM - 1
        xpnew(idir) = two*xpbar(idir) - xpold(idir)
        dXp(idir) = xpnew(idir) - xpold(idir)
        sign(idir) = 1
      enddo
     
      i0 = 0
      bc_particle = 0

c     xpold can change, don't change the one passed in
      xpold = xpold_save

c     do this after setting dXp
      if( bc_check_left(i0)==1 ) then
        if(xpold(i0)<left_edge(i0)) then
          xpold(i0) = left_edge(i0)
          bc_particle = 1
        endif
        if(xpnew(i0)<left_edge(i0)) then
          xpnew(i0) = left_edge(i0)
          bc_particle = 1
        endif
      endif
      if( bc_check_right(i0)==1 ) then
        if(xpold(i0)>right_edge(i0)) then
          xpold(i0) = right_edge(i0)
          bc_particle = 1
        endif
        if(xpnew(i0)>right_edge(i0)) then
          xpnew(i0) = right_edge(i0)
          bc_particle = 1
        endif
      endif

c     compute the index of the left most cell/edge that contains this particle cloud
      num_segments = 1
      do idir = 0, CH_SPACEDIM - 1
        index_stag_old(idir) = floor((xpold(idir) - left_edge(idir)) / dx(idir))
        index_stag_new(idir) = floor((xpnew(idir) - left_edge(idir)) / dx(idir))
        if(index_stag_new(idir)<index_stag_old(idir)) then
          sign(idir) = -1
        endif
        cell_crossings(idir) = ABS(index_stag_new(idir) - index_stag_old(idir))
        num_segments = num_segments + cell_crossings(idir)
      enddo

c     calculate the initial Xcell in each direction
      do idir = 0, CH_SPACEDIM -1
        Xcell(idir) = left_edge(idir) + (index_stag_old(idir) + half*(1-sign(idir)) + 0.5)*dx(idir)
      enddo

      CHF_DTERM[ii_next=index_stag_old(0); 
                jj_next=index_stag_old(1); 
                kk_next=index_stag_old(2)]

      xpold0 = xpold
      do nn=0, num_segments-1

        CHF_DTERM[ii=ii_next; 
                  jj=jj_next; 
                  kk=kk_next]

        if(nn==num_segments-1) then
          xpnew0 = xpnew
          dXp_sub = xpnew0 - xpold0
        else
          ii_next = ii + sign(i0)
          Xcell(i0) = Xcell(i0) + sign(i0)*dx(i0)
          xpnew0(i0) = Xcell(i0)
          dXp_sub(i0) = xpnew0(i0) - xpold0(i0)
        endif

c     interpolate Ex to particle
        if( dXp(i0).ne.zero ) then
          seg_factor = dXp_sub(i0)/dXp(i0)
        else
          seg_factor = 1.d0 
        endif 
 
        weight = seg_factor
        Epx = Epx + weight*Ex(CHF_IX[ii; jj; kk]) 
        
c     update xpold
        xpold0 = xpnew0
            
      enddo

c      
c     cloud in cell for Ey, Ez, Bx, By, and Bz
c

      do idir = 0, CH_SPACEDIM - 1
        index_stag(idir) = floor((xpbar(idir) - left_edge(idir)) / dx(idir))
        index(idir) = floor((xpbar(idir) - left_edge(idir) - 0.5d0*dx(idir)) / dx(idir))
      enddo

      ii = index_stag(0)
      dEpy(0) = (Ey(CHF_IX[ii+1;0;0]) - Ey(CHF_IX[ii;0;0]))/two/dx(0)
      dEpz(0) = (Ez(CHF_IX[ii+1;0;0]) - Ez(CHF_IX[ii;0;0]))/two/dx(0)
      dBpx(0) = (Bx(CHF_IX[ii+1;0;0]) - Bx(CHF_IX[ii;0;0]))/two/dx(0)

      ii = index(0) 
      dEpx(0) =  zero
      dBpy(0) = (By(CHF_IX[ii+1;0;0]) - By(CHF_IX[ii;0;0]))/two/dx(0)
      dBpz(0) = (Bz(CHF_IX[ii+1;0;0]) - Bz(CHF_IX[ii;0;0]))/two/dx(0)

c
c     reset dEpx/dy (dy=dXp) to account for cell crossings
c
      if( dXp(i0).ne.zero ) then
        if( bc_particle==1 ) then
          dEpx(0) = -Epx/dXp(i0)
        else
          ii = index_stag_new(0)
          dEpx(0) = -(Epx - Ex(CHF_IX[ii;0;0]))/dXp(i0)
        endif
      endif

      end

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c  Charge-conserving deposit for particle current density using a combination
c  of CIC and TSC interpolation with cell crossings included
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine cc1_1d_deposit_current(
     &                       CHF_FRA1[rhoVx],
     &                       CHF_FRA1[rhoVy],
     &                       CHF_FRA1[rhoVz],
     &                       CHF_CONST_INT[ghosts],
     &                       CHF_CONST_INTVECT[bc_check_left],
     &                       CHF_CONST_INTVECT[bc_check_right],
     &                       CHF_CONST_REALVECT[left_edge],
     &                       CHF_CONST_REALVECT[right_edge],
     &                       CHF_CONST_REALVECT[dx],
     &                       CHF_CONST_REALVECT[xpold_save],
     &                       CHF_CONST_REALVECT[xpbar],
     &                       CHF_CONST_REAL[vpx], 
     &                       CHF_CONST_REAL[vpy], 
     &                       CHF_CONST_REAL[vpz], 
     &                       CHF_CONST_REAL[dt], 
     &                       CHF_CONST_REAL[qp]) 

      integer index(0:CH_SPACEDIM - 1), index_stag(0:CH_SPACEDIM - 1)
      integer index_old(0:CH_SPACEDIM - 1), index_new(0:CH_SPACEDIM - 1)
      integer cell_crossings(0:CH_SPACEDIM - 1), idir, num_segments
      REAL_T CHF_DDECL[l0;l1;l2], CHF_DDECL[w0;w1;w2]
      REAL_T dXp(0:CH_SPACEDIM - 1), dXp_sub(0:CH_SPACEDIM - 1) 
      REAL_T xpold(0:CH_SPACEDIM - 1), xpnew(0:CH_SPACEDIM - 1)
      REAL_T xpold0(0:CH_SPACEDIM - 1), xpnew0(0:CH_SPACEDIM - 1) 
      REAL_T Xcell(0:CH_SPACEDIM - 1), xpbar0(0:CH_SPACEDIM - 1)
      REAL_T volume, rhop, weight, seg_factor
      integer nn, sign(0:CH_SPACEDIM - 1), i0
      integer ii, jj, kk, ii_next, jj_next, kk_next 

c     compute the cell volume and particle density on the grid
      volume = CHF_DTERM[dx(0);*dx(1);*dx(2)]
      rhop = qp / volume

c     xpold can change, don't change the one passed in
      xpold = xpold_save

c     compute the new particle position
      do idir = 0, CH_SPACEDIM - 1
        xpnew(idir) = two*xpbar(idir) - xpold(idir)
        dXp(idir) = xpnew(idir) - xpold(idir)
        sign(idir) = 1
      enddo
     
      i0 = 0
      seg_factor = 1.0

c     do this after setting dXp    
      if( bc_check_left(i0)==1 ) then
        if(xpold(i0)<left_edge(i0)) then
          xpold(i0) = left_edge(i0)
        endif
        if(xpnew(i0)<left_edge(i0)) then
          xpnew(i0) = left_edge(i0)
        endif
      endif
      if( bc_check_right(i0)==1 ) then
        if(xpold(i0)>right_edge(i0)) then
          xpold(i0) = right_edge(i0)
        endif
        if(xpnew(i0)>right_edge(i0)) then
          xpnew(i0) = right_edge(i0)
        endif
      endif

c     compute the index of the left most cell/edge that contains this particle cloud
      num_segments = 1
      do idir = 0, CH_SPACEDIM - 1
        index_old(idir) = floor((xpold(idir) - left_edge(idir) - 0.5d0*dx(idir)) / dx(idir))
        index_new(idir) = floor((xpnew(idir) - left_edge(idir) - 0.5d0*dx(idir)) / dx(idir))
        if(index_new(idir)<index_old(idir)) then
          sign(idir) = -1
        endif
        cell_crossings(idir) = ABS(index_new(idir) - index_old(idir))
        num_segments = num_segments + cell_crossings(idir)
      enddo

      if(num_segments>ghosts+1) then
        print*, "CC1_1D_DEPOSIT: num_segments = ", num_segments
        STOP 'ERROR, particle crossing more cell than allowed. Decrease time step or increase ghost layers'
      endif      

c     calculate the initial Xcell in each direction
      do idir = 0, CH_SPACEDIM -1
        Xcell(idir) = left_edge(idir) + (index_old(idir) + half*(1-sign(idir)) + 0.5)*dx(idir)
      enddo

      CHF_DTERM[ii_next=index_old(0); 
                jj_next=index_old(1); 
                kk_next=index_old(2)]

      xpold0 = xpold
      do nn=0, num_segments-1

        CHF_DTERM[ii=ii_next; 
                  jj=jj_next; 
                  kk=kk_next]

        if(nn==num_segments-1) then
          xpnew0 = xpnew
          dXp_sub = xpnew0 - xpold0
          if(abs(dXp_sub(i0))>0.0) seg_factor = dXp_sub(i0)/dXp(i0)
        else
          ii_next = ii + sign(i0)
          Xcell(i0) = Xcell(i0) + sign(i0)*dx(i0)
          xpnew0(i0) = Xcell(i0)
          dXp_sub(i0) = xpnew0(i0) - xpold0(i0)
          seg_factor = dXp_sub(i0)/dXp(i0)
        endif
        
c     deposit the particle x-current to the grid
        
        xpbar0(i0) = half*(xpnew0(i0) + xpold0(i0))
        l0 = left_edge(i0) + ii*dx(i0) + 0.5d0*dx(i0) - xpbar0(i0)
        w0 = 1.d0 - abs(l0/dx(i0))

        weight = w0*seg_factor
        rhoVx(CHF_IX[ii; jj; kk]) = 
#ifdef NEW_EXACT_CHARGE_CONSERVATION
     &  rhoVx(CHF_IX[ii; jj; kk]) + dXp(i0)/dt * rhop * weight
#else
     &  rhoVx(CHF_IX[ii; jj; kk]) + vpx * rhop * weight
#endif     
   
        weight = (1.d0-w0)*seg_factor
        rhoVx(CHF_IX[ii+1; jj; kk]) = 
#ifdef NEW_EXACT_CHARGE_CONSERVATION
     &  rhoVx(CHF_IX[ii+1; jj; kk]) + dXp(i0)/dt * rhop * weight
#else
     &  rhoVx(CHF_IX[ii+1; jj; kk]) + vpx * rhop * weight
#endif     
   
c     update xpold
        xpold0 = xpnew0
            
      enddo

c
c     deposit the particle y an z current to the grid
c

      do idir = 0, CH_SPACEDIM - 1
        index_stag(idir) = floor((xpbar(idir) - left_edge(idir)) / dx(idir))
      enddo

      CHF_DTERM[
      do ii = index_stag(0), index_stag(0) + 1
        l0 = ii*dx(0) - xpbar(0) + left_edge(0)
        w0 = 1.d0 - abs(l0/dx(0));
        do jj = 1,2
          l1 = 0
          w1 = 1.d0;
          do kk = 1,2
            l2 = 0
            w2 = 1.d0 ]

            weight = CHF_DTERM[w0; *w1; *w2]
            rhoVy(CHF_IX[ii; jj; kk]) = 
     &      rhoVy(CHF_IX[ii; jj; kk]) + vpy * rhop * weight

            rhoVz(CHF_IX[ii; jj; kk]) = 
     &      rhoVz(CHF_IX[ii; jj; kk]) + vpz * rhop * weight

      CHF_DTERM[
          enddo;
        enddo;
      enddo]

      end

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c  Charge-conserving interpolation of fields to particles using a combination
c  of CIC and TSC interpolation with cell crossings included (needed for energy conservation)
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine cc1_1d_interpolate_fields( CHF_REAL[Epx],
     &                                   CHF_REAL[Epy],
     &                                   CHF_REAL[Epz],
     &                                   CHF_REAL[Bpx],
     &                                   CHF_REAL[Bpy],
     &                                   CHF_REAL[Bpz],
     &                                   CHF_CONST_FRA1[Ex],
     &                                   CHF_CONST_FRA1[Ey],
     &                                   CHF_CONST_FRA1[Ez],
     &                                   CHF_CONST_FRA1[Bx],
     &                                   CHF_CONST_FRA1[By],
     &                                   CHF_CONST_FRA1[Bz],
     &                                   CHF_CONST_INT[ghosts],
     &                                   CHF_CONST_INTVECT[bc_check_left],
     &                                   CHF_CONST_INTVECT[bc_check_right],
     &                                   CHF_CONST_REALVECT[left_edge],
     &                                   CHF_CONST_REALVECT[right_edge],
     &                                   CHF_CONST_REALVECT[dx],
     &                                   CHF_CONST_REALVECT[xpold_save],
     &                                   CHF_CONST_REALVECT[xpbar] )

      integer CHF_DDECL[ii_stag;jj_stag;kk_stag]
      REAL_T CHF_DDECL[l0_stag;l1_stag;l2_stag]
      REAL_T CHF_DDECL[w0_stag;w1_stag;w2_stag]
      
      integer index(0:CH_SPACEDIM - 1), index_stag(0:CH_SPACEDIM - 1)
      integer index_old(0:CH_SPACEDIM - 1), index_new(0:CH_SPACEDIM - 1)
      integer cell_crossings(0:CH_SPACEDIM - 1), idir, num_segments
      REAL_T CHF_DDECL[l0;l1;l2], CHF_DDECL[w0;w1;w2]
      REAL_T dXp(0:CH_SPACEDIM - 1), dXp_sub(0:CH_SPACEDIM - 1) 
      REAL_T xpold(0:CH_SPACEDIM - 1), xpnew(0:CH_SPACEDIM - 1)
      REAL_T xpold0(0:CH_SPACEDIM - 1), xpnew0(0:CH_SPACEDIM - 1) 
      REAL_T Xcell(0:CH_SPACEDIM - 1), xpbar0(0:CH_SPACEDIM - 1)
      REAL_T weight, dXp_sub02, seg_factor
      integer nn, sign(0:CH_SPACEDIM - 1), i0
      integer ii, jj, kk, ii_next, jj_next, kk_next 

c     xpold can change, don't change the one passed in
      xpold = xpold_save

c     compute the new particle position
      do idir = 0, CH_SPACEDIM - 1
        xpnew(idir) = two*xpbar(idir) - xpold(idir)
        dXp(idir) = xpnew(idir) - xpold(idir)
        sign(idir) = 1
      enddo
     
      i0 = 0
      seg_factor = 1.0

c     do this after setting dXp
      if( bc_check_left(i0)==1 ) then
        if(xpold(i0)<left_edge(i0)) then
          xpold(i0) = left_edge(i0)
        endif
        if(xpnew(i0)<left_edge(i0)) then
          xpnew(i0) = left_edge(i0)
        endif
      endif
      if( bc_check_right(i0)==1 ) then
        if(xpold(i0)>right_edge(i0)) then
          xpold(i0) = right_edge(i0)
        endif
        if(xpnew(i0)>right_edge(i0)) then
          xpnew(i0) = right_edge(i0)
        endif
      endif

c     compute the index of the left most cell/edge that contains this particle cloud
      num_segments = 1
      do idir = 0, CH_SPACEDIM - 1
        index_old(idir) = floor((xpold(idir) - left_edge(idir) - 0.5d0*dx(idir)) / dx(idir))
        index_new(idir) = floor((xpnew(idir) - left_edge(idir) - 0.5d0*dx(idir)) / dx(idir))
        if(index_new(idir)<index_old(idir)) then
          sign(idir) = -1
        endif
        cell_crossings(idir) = ABS(index_new(idir) - index_old(idir))
        num_segments = num_segments + cell_crossings(idir)
      enddo

      if(num_segments>ghosts+1) then
        print*, "CC1_1D_INTERP: num_segments = ", num_segments
        STOP 'ERROR, particle crossing more cell than allowed. Decrease time step or increase ghost layers'
      endif      

c     calculate the initial Xcell in each direction
      do idir = 0, CH_SPACEDIM -1
        Xcell(idir) = left_edge(idir) + (index_old(idir) + half*(1-sign(idir)) + 0.5)*dx(idir)
      enddo

      CHF_DTERM[ii_next=index_old(0); 
                jj_next=index_old(1); 
                kk_next=index_old(2)]

      xpold0 = xpold
      do nn=0, num_segments-1

        CHF_DTERM[ii=ii_next; 
                  jj=jj_next; 
                  kk=kk_next]

        if(nn==num_segments-1) then
          xpnew0 = xpnew
          dXp_sub = xpnew0 - xpold0
          if( dXp(i0).ne.zero ) then 
            seg_factor = dXp_sub(i0)/dXp(i0)
          endif
        else
          ii_next = ii + sign(i0)
          Xcell(i0) = Xcell(i0) + sign(i0)*dx(i0)
          xpnew0(i0) = Xcell(i0)
          dXp_sub(i0) = xpnew0(i0) - xpold0(i0)
          seg_factor = dXp_sub(i0)/dXp(i0)
        endif

        xpbar0(i0) = half*(xpnew0(i0) + xpold0(i0))
        l0 = left_edge(i0) + ii*dx(i0) + 0.5d0*dx(i0) - xpbar0(i0)
        w0 = 1.d0 - abs(l0/dx(i0))

c     interpolate Ex to particle

        weight = w0*seg_factor
        Epx = Epx + weight*Ex(CHF_IX[ii; jj; kk]) 
        
        weight = (1.d0-w0)*seg_factor
        Epx = Epx + weight*Ex(CHF_IX[ii+1; jj; kk])
        
c     update xpold
        xpold0 = xpnew0
            
      enddo

c      
c     cloud in cell for Ey, Ez, Bx, By, and Bz
c

      do idir = 0, CH_SPACEDIM - 1
        index_stag(idir) = floor((xpbar(idir) - left_edge(idir)) / dx(idir))
        index(idir) = floor((xpbar(idir) - left_edge(idir) - 0.5d0*dx(idir)) / dx(idir))
      enddo

      CHF_DTERM[
      do ii = index(0), index(0) + 1
        l0 = ii*dx(0) + 0.5d0*dx(0) - xpbar(0) + left_edge(0)
        ii_stag = ii-index(0)+index_stag(0)
        l0_stag = ii_stag*dx(0) - xpbar(0) + left_edge(0)
        w0 = 1.d0 - abs(l0 / dx(0))
        w0_stag = 1.d0 - abs(l0_stag / dx(0));
        do jj = index(1), index(1) + 1
          l1 = jj*dx(1) + 0.5d0*dx(1) - xpbar(1) + left_edge(1)
          jj_stag = jj-index(1)+index_stag(1)
          l1_stag = jj_stag*dx(1) - xpbar(1) + left_edge(1)
          w1 = 1.d0 - abs(l1 / dx(1))
          w1_stag = 1.d0 - abs(l1_stag / dx(1));
          do kk = index(2), index(2) + 1
            l2 = kk*dx(2) + 0.5d0*dx(2) - xpbar(2) + left_edge(2)
            kk_stag = kk-index(2)+index_stag(2)
            l2_stag = kk_stag*dx(2) - xpbar(2) + left_edge(2)
            w2 = 1.d0 - abs(l2 / dx(2))
            w2_stag = 1.d0 - abs(l2_stag / dx(2))]

            weight = CHF_DTERM[w0_stag; *w1; *w2_stag]
            Epy = Epy + weight*Ey(CHF_IX[ii_stag; jj; kk_stag])

            weight = CHF_DTERM[w0_stag; *w1_stag; *w2]
            Epz = Epz + weight*Ez(CHF_IX[ii_stag; jj_stag; kk])

            weight = CHF_DTERM[w0_stag; *w1; *w2]
            Bpx = Bpx + weight*Bx(CHF_IX[ii_stag; jj; kk])
            
            weight = CHF_DTERM[w0; *w1_stag; *w2]
            Bpy = Bpy + weight*By(CHF_IX[ii; jj_stag; kk])
            
            weight = CHF_DTERM[w0; *w1; *w2_stag]
            Bpz = Bpz + weight*Bz(CHF_IX[ii; jj; kk_stag])

      CHF_DTERM[
          enddo;
        enddo;
      enddo]

      end

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c  derivative of fields wrt y = xpnew - xpold for 1D CC1 interpolation scheme
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine cc1_1d_field_derivatives( CHF_REALVECT[dEpx],
     &                                     CHF_REALVECT[dEpy],
     &                                     CHF_REALVECT[dEpz],
     &                                     CHF_REALVECT[dBpx],
     &                                     CHF_REALVECT[dBpy],
     &                                     CHF_REALVECT[dBpz],
     &                                     CHF_CONST_FRA1[Ex],
     &                                     CHF_CONST_FRA1[Ey],
     &                                     CHF_CONST_FRA1[Ez],
     &                                     CHF_CONST_FRA1[Bx],
     &                                     CHF_CONST_FRA1[By],
     &                                     CHF_CONST_FRA1[Bz],
     &                                     CHF_CONST_INTVECT[bc_check_left],
     &                                     CHF_CONST_INTVECT[bc_check_right],
     &                                     CHF_CONST_REALVECT[left_edge],
     &                                     CHF_CONST_REALVECT[right_edge],
     &                                     CHF_CONST_REALVECT[dx],
     &                                     CHF_CONST_REALVECT[xpold_save],
     &                                     CHF_CONST_REALVECT[xpbar] )

      integer CHF_DDECL[ii_stag;jj_stag;kk_stag]
      REAL_T CHF_DDECL[l0_stag;l1_stag;l2_stag]
      REAL_T CHF_DDECL[w0_stag;w1_stag;w2_stag]
      REAL_T Epx, wup, wdn

      integer index(0:CH_SPACEDIM - 1), index_stag(0:CH_SPACEDIM - 1)
      integer index_old(0:CH_SPACEDIM - 1), index_new(0:CH_SPACEDIM - 1)
      integer cell_crossings(0:CH_SPACEDIM - 1), idir, num_segments
      REAL_T CHF_DDECL[l0;l1;l2], CHF_DDECL[w0;w1;w2]
      REAL_T dXp(0:CH_SPACEDIM - 1), dXp_sub(0:CH_SPACEDIM - 1) 
      REAL_T xpold(0:CH_SPACEDIM - 1), xpnew(0:CH_SPACEDIM - 1)
      REAL_T xpold0(0:CH_SPACEDIM - 1), xpnew0(0:CH_SPACEDIM - 1) 
      REAL_T Xcell(0:CH_SPACEDIM - 1), xpbar0(0:CH_SPACEDIM - 1)
      REAL_T weight, dXp_sub02, seg_factor
      integer nn, sign(0:CH_SPACEDIM - 1), i0
      integer ii, jj, kk, ii_next, jj_next, kk_next 
      integer bc_particle

c     xpold can change, don't change the one passed in
      xpold = xpold_save

c     compute the new particle position
      do idir = 0, CH_SPACEDIM - 1
        xpnew(idir) = two*xpbar(idir) - xpold(idir)
        dXp(idir) = xpnew(idir) - xpold(idir)
        sign(idir) = 1
      enddo
     
      i0 = 0
      bc_particle = 0
      seg_factor = 1.0

c     do this after setting dXp
      if( bc_check_left(i0)==1 ) then
        if(xpold(i0)<left_edge(i0)) then
          xpold(i0) = left_edge(i0)
          bc_particle = 1
        endif
        if(xpnew(i0)<left_edge(i0)) then
          xpnew(i0) = left_edge(i0)
          bc_particle = 1
        endif
      endif
      if( bc_check_right(i0)==1 ) then
        if(xpold(i0)>right_edge(i0)) then
          xpold(i0) = right_edge(i0)
          bc_particle = 1
        endif
        if(xpnew(i0)>right_edge(i0)) then
          xpnew(i0) = right_edge(i0)
          bc_particle = 1
        endif
      endif

c     compute the index of the left most cell/edge that contains this particle cloud
      num_segments = 1
      do idir = 0, CH_SPACEDIM - 1
        index_old(idir) = floor((xpold(idir) - left_edge(idir) - 0.5d0*dx(idir)) / dx(idir))
        index_new(idir) = floor((xpnew(idir) - left_edge(idir) - 0.5d0*dx(idir)) / dx(idir))
        if(index_new(idir)<index_old(idir)) then
          sign(idir) = -1
        endif
        cell_crossings(idir) = ABS(index_new(idir) - index_old(idir))
        num_segments = num_segments + cell_crossings(idir)
      enddo

c     calculate the initial Xcell in each direction
      do idir = 0, CH_SPACEDIM -1
        Xcell(idir) = left_edge(idir) + (index_old(idir) + half*(1-sign(idir)) + 0.5)*dx(idir)
      enddo

      CHF_DTERM[ii_next=index_old(0); 
                jj_next=index_old(1); 
                kk_next=index_old(2)]

      xpold0 = xpold
      do nn=0, num_segments-1

        CHF_DTERM[ii=ii_next; 
                  jj=jj_next; 
                  kk=kk_next]

        if(nn==num_segments-1) then
          xpnew0 = xpnew
          dXp_sub = xpnew0 - xpold0
          if( dXp(i0).ne.zero ) then
            seg_factor = dXp_sub(i0)/dXp(i0)
          endif
        else
          ii_next = ii + sign(i0)
          Xcell(i0) = Xcell(i0) + sign(i0)*dx(i0)
          xpnew0(i0) = Xcell(i0)
          dXp_sub(i0) = xpnew0(i0) - xpold0(i0)
          seg_factor = dXp_sub(i0)/dXp(i0)
        endif

        xpbar0(i0) = half*(xpnew0(i0) + xpold0(i0))
        l0 = left_edge(i0) + ii*dx(i0) + 0.5d0*dx(i0) - xpbar0(i0)
        w0 = 1.d0 - abs(l0/dx(i0))

c     interpolate Ex to particle

        weight = w0*seg_factor
        Epx = Epx + weight*Ex(CHF_IX[ii; jj; kk]) 
        
        weight = (1.d0-w0)*seg_factor
        Epx = Epx + weight*Ex(CHF_IX[ii+1; jj; kk])
        
c     update xpold
        xpold0 = xpnew0
            
      enddo

c      
c     cloud in cell for Ey, Ez, Bx, By, and Bz
c

      do idir = 0, CH_SPACEDIM - 1
        index_stag(idir) = floor((xpbar(idir) - left_edge(idir)) / dx(idir))
        index(idir) = floor((xpbar(idir) - left_edge(idir) - 0.5d0*dx(idir)) / dx(idir))
      enddo

      ii = index_stag(0) 
      dEpy(0) = (Ey(CHF_IX[ii+1;0;0]) - Ey(CHF_IX[ii;0;0]))/two/dx(0)
      dEpz(0) = (Ez(CHF_IX[ii+1;0;0]) - Ez(CHF_IX[ii;0;0]))/two/dx(0)
      dBpx(0) = (Bx(CHF_IX[ii+1;0;0]) - Bx(CHF_IX[ii;0;0]))/two/dx(0)

      ii = index(0) 
      dEpx(0) = (Ex(CHF_IX[ii+1;0;0]) - Ex(CHF_IX[ii;0;0]))/two/dx(0)
      dBpy(0) = (By(CHF_IX[ii+1;0;0]) - By(CHF_IX[ii;0;0]))/two/dx(0)
      dBpz(0) = (Bz(CHF_IX[ii+1;0;0]) - Bz(CHF_IX[ii;0;0]))/two/dx(0)

c
c     reset dEpx/dy (dy=dXp) to account for cell crossings
c
      if( bc_particle==1 ) then
          dEpx(0) = -Epx/dXp(i0)
      else
        if( num_segments>1 ) then
          wdn = w0
          wup = 1.0 - w0
          ii = ii_next
          dEpx(0) = -Epx/dXp(i0) 
     &            + (Ex(CHF_IX[ii;0;0])*wdn + Ex(CHF_IX[ii+1;0;0])*wup)/dXp(i0)
     &            + (Ex(CHF_IX[ii+1;0;0]) - Ex(CHF_IX[ii;0;0]))/two/dx(0)*seg_factor
        endif
      endif

      end

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine cc1_2d_deposit_current(
     &                       CHF_FRA1[rhoVx],
     &                       CHF_FRA1[rhoVy],
     &                       CHF_FRA1[rhoVz],
     &                       CHF_CONST_INT[ghosts],
     &                       CHF_CONST_INTVECT[bc_check_left],
     &                       CHF_CONST_INTVECT[bc_check_right],
     &                       CHF_CONST_REALVECT[left_edge],
     &                       CHF_CONST_REALVECT[right_edge],
     &                       CHF_CONST_REALVECT[dx],
     &                       CHF_CONST_REALVECT[xpold_save],
     &                       CHF_CONST_REALVECT[xpbar],
     &                       CHF_CONST_REAL[vpx], 
     &                       CHF_CONST_REAL[vpy], 
     &                       CHF_CONST_REAL[vpz], 
     &                       CHF_CONST_REAL[dt], 
     &                       CHF_CONST_REAL[qp]) 

      integer index_stag(0:CH_SPACEDIM - 1)
      integer index_start(0:CH_SPACEDIM - 1)
      integer index_old(0:CH_SPACEDIM - 1), index_new(0:CH_SPACEDIM - 1)
      integer cell_crossings(0:CH_SPACEDIM - 1), idir, num_segments
      
      REAL_T l0, l1, w0, w1, delta0, delta1
      REAL_T dXp(0:CH_SPACEDIM - 1), dXp_sub(0:CH_SPACEDIM - 1)
      REAL_T xpold(0:CH_SPACEDIM - 1), xpnew(0:CH_SPACEDIM - 1)
      REAL_T xpold0(0:CH_SPACEDIM - 1), xpnew0(0:CH_SPACEDIM - 1)
      REAL_T xpbar0(0:CH_SPACEDIM - 1), seg_factor(0:CH_SPACEDIM - 1)
      REAL_T Xcell(0:CH_SPACEDIM - 1)
      REAL_T volume, rhop, weight, slope, slope_inv, dXp_sub02
      integer nn, sign(0:CH_SPACEDIM - 1), i0, i1
      integer ii, jj, kk, ii_next, jj_next, kk_next 
      integer ii_stag, jj_stag
      REAL_T w0_stag, w1_stag, l0_stag, l1_stag, delta0_stag, delta1_stag

c     compute the cell volume and particle density on the grid
      volume = CHF_DTERM[dx(0);*dx(1);*dx(2)]
      rhop = qp / volume

c     xpold can change, don't change the one passed in
      xpold = xpold_save

c     compute the new particle position
      do idir = 0, CH_SPACEDIM - 1
        xpnew(idir) = two*xpbar(idir) - xpold(idir)
        dXp(idir) = xpnew(idir) - xpold(idir)
        sign(idir) = 1
      enddo
     
c     compute slopes assuming 2D
      i0 = 0
      i1 = CH_SPACEDIM-1
      slope = dXp(i1)/dXp(i0)
      slope_inv = 1/slope

c     do check for bc particles after setting dXp 
      call truncate_boundaries( xpold, xpnew,
     &                          bc_check_left, bc_check_right,
     &                          left_edge, right_edge,
     &                          slope, slope_inv )

c     compute the index of the left most cell/edge that contains this particle cloud
      num_segments = 1
      do idir = 0, CH_SPACEDIM - 1
        index_old(idir) = floor((xpold(idir) - left_edge(idir) - 0.5d0*dx(idir)) / dx(idir))
        index_new(idir) = floor((xpnew(idir) - left_edge(idir) - 0.5d0*dx(idir)) / dx(idir))
        if(index_new(idir)<index_old(idir)) then
          sign(idir) = -1
        endif
        cell_crossings(idir) = ABS(index_new(idir) - index_old(idir))
        num_segments = num_segments + cell_crossings(idir)
      enddo
      
      if(num_segments>ghosts+1) then
        print*, "CC1_2D_DEPOSIT: num_segments = ", num_segments
        STOP 'ERROR, particle crossing more cell than allowed. Decrease time step or increase ghost layers'
      endif      

c     calculate the initial Xcell in each direction
      do idir = 0, CH_SPACEDIM -1
        Xcell(idir) = left_edge(idir) + (index_old(idir) + half*(1-sign(idir)) + 0.5)*dx(idir)
      enddo

      xpold0 = xpold
      CHF_DTERM[ii_next=index_old(0); 
                jj_next=index_old(1); 
                kk_next=index_old(2)]

      do nn=0, num_segments-1

        CHF_DTERM[ii=ii_next; 
                  jj=jj_next; 
                  kk=kk_next]

        if(nn==num_segments-1) then
          xpnew0 = xpnew
          dXp_sub = xpnew0 - xpold0
        else if(cell_crossings(i0)==0) then
          jj_next = jj + sign(i1)
          Xcell(i1) = Xcell(i1) + sign(i1)*dx(i1)
          xpnew0(i1) = Xcell(i1)
          dXp_sub(i1) = xpnew0(i1) - xpold0(i1)
          dXp_sub(i0) = slope_inv*dXp_sub(i1)
          xpnew0(i0) = xpold0(i0) + dXp_sub(i0)
        else if(cell_crossings(i1)==0) then
          ii_next = ii + sign(i0)
          Xcell(i0) = Xcell(i0) + sign(i0)*dx(i0)
          xpnew0(i0) = Xcell(i0)
          dXp_sub(i0) = xpnew0(i0) - xpold0(i0)
          dXp_sub(i1) = slope*dXp_sub(i0)
          xpnew0(i1) = xpold0(i1) + dXp_sub(i1)
        else
          xpnew0(i0) = Xcell(i0) + sign(i0)*dx(i0)
          xpnew0(i1) = Xcell(i1) + sign(i1)*dx(i1)
          dXp_sub(i0) = xpnew0(i0) - xpold0(i0)
          dXp_sub(i1) = xpnew0(i1) - xpold0(i1)
          dXp_sub02 = slope_inv*dXp_sub(i1)

          if(abs(dXp_sub(i0))<abs(dXp_sub02)) then
            dXp_sub(i1) = slope*dXp_sub(i0)
            xpnew0(i1) = xpold0(i1) + dXp_sub(i1)
            Xcell(i0) = xpnew0(i0)
            ii_next = ii + sign(i0)
            cell_crossings(i0) = cell_crossings(i0) - 1
          else
            dXp_sub(i0) = slope_inv*dXp_sub(i1)
            xpnew0(i0) = xpold0(i0) + dXp_sub(i0)
            Xcell(i1) = xpnew0(i1)
            jj_next = jj + sign(i1)
            cell_crossings(i1) = cell_crossings(i1) - 1
          endif

        endif

        if( dXp(i0).ne.zero) then
          seg_factor(i0) = dXp_sub(i0)/dXp(i0)
        else
          seg_factor(i0) = 1.d0
        endif        
        if( dXp(i1).ne.zero ) then
          seg_factor(i1) = dXp_sub(i1)/dXp(i1)
        else
          seg_factor(i1) = 1.d0
        endif        

c     compute CIC weights
        xpbar0 = half*(xpold0 + xpnew0)
        delta0 = (xpbar0(i0) - (left_edge(i0) + (ii+0.5)*dx(i0)))/dx(i0)
        delta1 = (xpbar0(i1) - (left_edge(i1) + (jj+0.5)*dx(i1)))/dx(i1)

c     get indicies for TSC weights
        do idir = 0, CH_SPACEDIM -1
          index_start(idir) = floor((xpbar0(idir) - left_edge(idir) - 0.5d0*dx(idir)) / dx(idir))
        enddo
  
c     deposit the particle x-current to the grid
        do jj_stag=index_start(i1), index_start(i1) + 2

          l1_stag = jj_stag*dx(i1) - xpold0(i1) + left_edge(i1)
          delta1_stag = abs(l1_stag/dx(i1))
          if (delta1_stag .lt. 0.5d0) then
            w1_stag = 0.75d0 - delta1_stag**2.d0
          else
            w1_stag = 0.5d0 * (1.5d0 - delta1_stag)**2.d0
          endif

          l1_stag = jj_stag*dx(i1) - xpnew0(i1) + left_edge(i1)
          delta1_stag = abs(l1_stag/dx(i1))
          if (delta1_stag .lt. 0.5d0) then
            w1_stag = w1_stag + 0.75d0 - delta1_stag**2.d0
          else
            w1_stag = w1_stag + 0.5d0 * (1.5d0 - delta1_stag)**2.d0
          endif
          w1_stag = half*w1_stag

          weight = (1.0 - delta0)*w1_stag*seg_factor(i0)
          rhoVx(CHF_IX[ii; jj_stag; kk]) = 
#ifdef NEW_EXACT_CHARGE_CONSERVATION
     &    rhoVx(CHF_IX[ii; jj_stag; kk]) + dXp(i0)/dt * rhop * weight
#else   
     &    rhoVx(CHF_IX[ii; jj_stag; kk]) + vpx * rhop * weight
#endif 
  
          weight = delta0*w1_stag*seg_factor(i0)
          rhoVx(CHF_IX[ii+1; jj_stag; kk]) = 
#ifdef NEW_EXACT_CHARGE_CONSERVATION
     &    rhoVx(CHF_IX[ii+1; jj_stag; kk]) + dXp(i0)/dt * rhop * weight
#else
     &    rhoVx(CHF_IX[ii+1; jj_stag; kk]) + vpx * rhop * weight
#endif
        enddo

c     deposit the particle y-current to the grid
        do ii_stag=index_start(i0), index_start(i0) + 2

          l0_stag = ii_stag*dx(i0) - xpold0(i0) + left_edge(i0)
          delta0_stag = abs(l0_stag/dx(i0))
          if (delta0_stag .lt. 0.5d0) then
            w0_stag = 0.75d0 - delta0_stag**2.d0
          else
            w0_stag = 0.5d0 * (1.5d0 - delta0_stag)**2.d0
          endif
          
          l0_stag = ii_stag*dx(i0) - xpnew0(i0) + left_edge(i0)
          delta0_stag = abs(l0_stag/dx(i0))
          if (delta0_stag .lt. 0.5d0) then
            w0_stag = w0_stag + 0.75d0 - delta0_stag**2.d0
          else
            w0_stag = w0_stag + 0.5d0 * (1.5d0 - delta0_stag)**2.d0
          endif
          w0_stag = half*w0_stag

          weight = w0_stag*(1.0 - delta1)*seg_factor(i1)
          rhoVy(CHF_IX[ii_stag; jj; kk]) = 
#ifdef NEW_EXACT_CHARGE_CONSERVATION
     &    rhoVy(CHF_IX[ii_stag; jj; kk]) + dXp(i1)/dt * rhop * weight
#else
     &    rhoVy(CHF_IX[ii_stag; jj; kk]) + vpy * rhop * weight
#endif
   
          weight = w0_stag*delta1*seg_factor(i1)
          rhoVy(CHF_IX[ii_stag; jj+1; kk]) = 
#ifdef NEW_EXACT_CHARGE_CONSERVATION
     &    rhoVy(CHF_IX[ii_stag; jj+1; kk]) + dXp(i1)/dt * rhop * weight
#else
     &    rhoVy(CHF_IX[ii_stag; jj+1; kk]) + vpy * rhop * weight
#endif        
        enddo

c     update xpold
        xpold0 = xpnew0
            
      enddo

c
c     deposit the particle z-current to the grid
c

      do idir = 0, CH_SPACEDIM - 1
        index_stag(idir) = floor((xpbar(idir) - left_edge(idir)) / dx(idir))
      enddo

      CHF_DTERM[
      do ii = index_stag(0), index_stag(0) + 1
        delta0 = (ii*dx(0) - xpbar(0) + left_edge(0))/dx(0)
        w0 = 1.d0 - abs(delta0);
        do jj = index_stag(1), index_stag(1) + 1
          delta1 = (jj*dx(1) - xpbar(1) + left_edge(1))/dx(1)
          w1 = 1.d0 - abs(delta1);
          do kk = 1,2]

            weight = w0*w1
            rhoVz(CHF_IX[ii; jj; kk]) = 
     &      rhoVz(CHF_IX[ii; jj; kk]) + vpz * rhop * weight

      CHF_DTERM[
          enddo;
        enddo;
      enddo]

      end

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c  Charge-conserving interpolation of fields to particles using a combination
c  of CIC and TSC interpolation with cell crossings included (needed for energy conservation)
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine cc1_2d_interpolate_fields( CHF_REAL[Epx],
     &                                   CHF_REAL[Epy],
     &                                   CHF_REAL[Epz],
     &                                   CHF_REAL[Bpx],
     &                                   CHF_REAL[Bpy],
     &                                   CHF_REAL[Bpz],
     &                                   CHF_CONST_FRA1[Ex],
     &                                   CHF_CONST_FRA1[Ey],
     &                                   CHF_CONST_FRA1[Ez],
     &                                   CHF_CONST_FRA1[Bx],
     &                                   CHF_CONST_FRA1[By],
     &                                   CHF_CONST_FRA1[Bz],
     &                                   CHF_CONST_INT[ghosts],
     &                                   CHF_CONST_INTVECT[bc_check_left],
     &                                   CHF_CONST_INTVECT[bc_check_right],
     &                                   CHF_CONST_REALVECT[left_edge],
     &                                   CHF_CONST_REALVECT[right_edge],
     &                                   CHF_CONST_REALVECT[dx],
     &                                   CHF_CONST_REALVECT[xpold_save],
     &                                   CHF_CONST_REALVECT[xpbar] )

      integer ii_stag, jj_stag, kk_stag
      REAL_T l0_stag, l1_stag, delta0_stag, delta1_stag
      REAL_T w0_stag, w1_stag, w2_stag
      integer index(0:CH_SPACEDIM - 1), index_stag(0:CH_SPACEDIM - 1)
      integer index_start(0:CH_SPACEDIM - 1)
      integer index_old(0:CH_SPACEDIM - 1), index_new(0:CH_SPACEDIM - 1)
      integer cell_crossings(0:CH_SPACEDIM - 1), idir, num_segments
      
      REAL_T l0, l1, l2, w0, w1, w2, delta0, delta1
      REAL_T dXp(0:CH_SPACEDIM - 1), dXp_sub(0:CH_SPACEDIM - 1)
      REAL_T xpold(0:CH_SPACEDIM - 1), xpnew(0:CH_SPACEDIM - 1)
      REAL_T xpold0(0:CH_SPACEDIM - 1), xpnew0(0:CH_SPACEDIM - 1)
      REAL_T xpbar0(0:CH_SPACEDIM - 1), seg_factor(0:CH_SPACEDIM - 1)
      REAL_T Xcell(0:CH_SPACEDIM - 1)
      REAL_T weight, slope, slope_inv, dXp_sub02
      integer nn, sign(0:CH_SPACEDIM - 1), i0, i1
      integer ii, jj, kk, ii_next, jj_next, kk_next 

c     xpold can change, don't change the one passed in
      xpold = xpold_save

c     compute the new particle position
      do idir = 0, CH_SPACEDIM - 1
        xpnew(idir) = two*xpbar(idir) - xpold(idir)
        dXp(idir) = xpnew(idir) - xpold(idir)
        sign(idir) = 1
      enddo
     
c     compute slopes assuming 2D
      i0 = 0
      i1 = CH_SPACEDIM-1
      slope = dXp(i1)/dXp(i0)
      slope_inv = 1/slope

c     do check for bc particles after setting dXp  
      call truncate_boundaries( xpold, xpnew,
     &                          bc_check_left, bc_check_right,
     &                          left_edge, right_edge,
     &                          slope, slope_inv )

c     compute the index of the left most cell/edge that contains this particle cloud
      num_segments = 1
      do idir = 0, CH_SPACEDIM - 1
        index_old(idir) = floor((xpold(idir) - left_edge(idir) - 0.5d0*dx(idir)) / dx(idir))
        index_new(idir) = floor((xpnew(idir) - left_edge(idir) - 0.5d0*dx(idir)) / dx(idir))
        if(index_new(idir)<index_old(idir)) then
          sign(idir) = -1
        endif
        cell_crossings(idir) = ABS(index_new(idir) - index_old(idir))
        num_segments = num_segments + cell_crossings(idir)
      enddo
      
      if(num_segments>ghosts+1) then
        print*, "CC1_2D_INTERP: num_segments = ", num_segments
        STOP 'ERROR, particle crossing more cell than allowed. Decrease time step or increase ghost layers'
      endif      

c     calculate the initial Xcell in each direction
      do idir = 0, CH_SPACEDIM -1
        Xcell(idir) = left_edge(idir) + (index_old(idir) + half*(1-sign(idir)) + 0.5)*dx(idir)
      enddo

      xpold0 = xpold
      CHF_DTERM[ii_next=index_old(0); 
                jj_next=index_old(1); 
                kk_next=index_old(2)]

      do nn=0, num_segments-1

        CHF_DTERM[ii=ii_next; 
                  jj=jj_next; 
                  kk=kk_next]

        if(nn==num_segments-1) then
          xpnew0 = xpnew
          dXp_sub = xpnew0 - xpold0
        else if(cell_crossings(i0)==0) then
          jj_next = jj + sign(i1)
          Xcell(i1) = Xcell(i1) + sign(i1)*dx(i1)
          xpnew0(i1) = Xcell(i1)
          dXp_sub(i1) = xpnew0(i1) - xpold0(i1)
          dXp_sub(i0) = slope_inv*dXp_sub(i1)
          xpnew0(i0) = xpold0(i0) + dXp_sub(i0)
        else if(cell_crossings(i1)==0) then
          ii_next = ii + sign(i0)
          Xcell(i0) = Xcell(i0) + sign(i0)*dx(i0)
          xpnew0(i0) = Xcell(i0)
          dXp_sub(i0) = xpnew0(i0) - xpold0(i0)
          dXp_sub(i1) = slope*dXp_sub(i0)
          xpnew0(i1) = xpold0(i1) + dXp_sub(i1)
        else
          xpnew0(i0) = Xcell(i0) + sign(i0)*dx(i0)
          xpnew0(i1) = Xcell(i1) + sign(i1)*dx(i1)
          dXp_sub(i0) = xpnew0(i0) - xpold0(i0)
          dXp_sub(i1) = xpnew0(i1) - xpold0(i1)
          dXp_sub02 = slope_inv*dXp_sub(i1)

          if(abs(dXp_sub(i0))<abs(dXp_sub02)) then
            dXp_sub(i1) = slope*dXp_sub(i0)
            xpnew0(i1) = xpold0(i1) + dXp_sub(i1)
            Xcell(i0) = xpnew0(i0)
            ii_next = ii + sign(i0)
            cell_crossings(i0) = cell_crossings(i0) - 1
          else
            dXp_sub(i0) = slope_inv*dXp_sub(i1)
            xpnew0(i0) = xpold0(i0) + dXp_sub(i0)
            Xcell(i1) = xpnew0(i1)
            jj_next = jj + sign(i1)
            cell_crossings(i1) = cell_crossings(i1) - 1
          endif

        endif

        if( dXp(i0).ne.zero) then
          seg_factor(i0) = dXp_sub(i0)/dXp(i0)
        else
          seg_factor(i0) = 1.d0
        endif
        if( dXp(i1).ne.zero) then
          seg_factor(i1) = dXp_sub(i1)/dXp(i1)
        else
          seg_factor(i1) = 1.d0
        endif

c     compute CIC weights
        xpbar0 = half*(xpold0 + xpnew0)
        delta0 = (xpbar0(i0) - (left_edge(i0) + (ii+0.5)*dx(i0)))/dx(i0)
        delta1 = (xpbar0(i1) - (left_edge(i1) + (jj+0.5)*dx(i1)))/dx(i1)

c     get indicies for TSC weights
        do idir = 0, CH_SPACEDIM -1
          index_start(idir) = floor((xpbar0(idir) - left_edge(idir) - 0.5d0*dx(idir)) / dx(idir))
        enddo

c     interpolate Ex to particle
        do jj_stag=index_start(i1), index_start(i1)+2

          l1_stag = jj_stag*dx(i1) - xpold0(i1) + left_edge(i1)
          delta1_stag = abs(l1_stag/dx(i1))
          if (delta1_stag .lt. 0.5d0) then
            w1_stag = 0.75d0 - delta1_stag**2.d0
          else
            w1_stag = 0.5d0 * (1.5d0 - delta1_stag)**2.d0
          endif

          l1_stag = jj_stag*dx(i1) - xpnew0(i1) + left_edge(i1)
          delta1_stag = abs(l1_stag/dx(i1))
          if (delta1_stag .lt. 0.5d0) then
            w1_stag = w1_stag + 0.75d0 - delta1_stag**2.d0
          else
            w1_stag = w1_stag + 0.5d0 * (1.5d0 - delta1_stag)**2.d0
          endif
          w1_stag = half*w1_stag

          weight = (1.0 - delta0)*w1_stag*seg_factor(i0)
          Epx = Epx + weight*Ex(CHF_IX[ii;jj_stag;kk]) 
        
          weight = delta0*w1_stag*seg_factor(i0)
          Epx = Epx + weight*Ex(CHF_IX[ii+1;jj_stag;kk])

        enddo

c     interpolate Ey to particle
        do ii_stag=index_start(i0), index_start(i0)+2

          l0_stag = ii_stag*dx(i0) - xpold0(i0) + left_edge(i0)
          delta0_stag = abs(l0_stag/dx(i0))
          if (delta0_stag .lt. 0.5d0) then
            w0_stag = 0.75d0 - delta0_stag**2.d0
          else
            w0_stag = 0.5d0 * (1.5d0 - delta0_stag)**2.d0
          endif

          l0_stag = ii_stag*dx(i0) - xpnew0(i0) + left_edge(i0)
          delta0_stag = abs(l0_stag/dx(i0))
          if (delta0_stag .lt. 0.5d0) then
            w0_stag = w0_stag + 0.75d0 - delta0_stag**2.d0
          else
            w0_stag = w0_stag + 0.5d0 * (1.5d0 - delta0_stag)**2.d0
          endif
          w0_stag = half*w0_stag

          weight = w0_stag*(1.0 - delta1)*seg_factor(i1)
          Epy = Epy + weight*Ey(CHF_IX[ii_stag;jj;kk]) 
        
          weight = w0_stag*delta1*seg_factor(i1)
          Epy = Epy + weight*Ey(CHF_IX[ii_stag;jj+1;kk])

        enddo

c     update xpold
        xpold0 = xpnew0
            
      enddo

c
c     cloud in cell for Ez, Bx, By, and Bz
c

      do idir = 0, CH_SPACEDIM - 1
        index(idir) = floor((xpbar(idir) - left_edge(idir) - 0.5d0*dx(idir)) / dx(idir))
        index_stag(idir) = floor((xpbar(idir) - left_edge(idir)) / dx(idir))
      enddo

      CHF_DTERM[
      do ii = index(0), index(0) + 1
        l0 = ii*dx(0) + 0.5d0*dx(0) - xpbar(0) + left_edge(0)
        ii_stag = ii-index(0)+index_stag(0)
        l0_stag = ii_stag*dx(0) - xpbar(0) + left_edge(0)
        w0 = 1.d0 - abs(l0 / dx(0))
        w0_stag = 1.d0 - abs(l0_stag / dx(0));
        do jj = index(1), index(1) + 1
          l1 = jj*dx(1) + 0.5d0*dx(1) - xpbar(1) + left_edge(1)
          jj_stag = jj-index(1)+index_stag(1)
          l1_stag = jj_stag*dx(1) - xpbar(1) + left_edge(1)
          w1 = 1.d0 - abs(l1 / dx(1))
          w1_stag = 1.d0 - abs(l1_stag / dx(1));
          do kk = index(2), index(2) + 1
            l2 = kk*dx(2) + 0.5d0*dx(2) - xpbar(2) + left_edge(2)
            kk_stag = kk-index(2)+index_stag(2)
            l2_stag = kk_stag*dx(2) - xpbar(2) + left_edge(2)
            w2 = 1.d0 - abs(l2 / dx(2))
            w2_stag = 1.d0 - abs(l2_stag / dx(2)) ]

            weight = CHF_DTERM[w0_stag; *w1_stag; *w2]
            Epz = Epz + weight*Ez(CHF_IX[ii_stag; jj_stag; kk])

            weight = CHF_DTERM[w0_stag; *w1; *w2]
            Bpx = Bpx + weight*Bx(CHF_IX[ii_stag; jj; kk])
            
            weight = CHF_DTERM[w0; *w1_stag; *w2]
            Bpy = Bpy + weight*By(CHF_IX[ii; jj_stag; kk])
            
            weight = CHF_DTERM[w0; *w1; *w2_stag]
            Bpz = Bpz + weight*Bz(CHF_IX[ii; jj; kk_stag])

      CHF_DTERM[
          enddo;
        enddo;
      enddo]

      end

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c       method to truncate positions based on boundaries
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine truncate_boundaries(
     &                       CHF_REALVECT[xpold],
     &                       CHF_REALVECT[xpnew],
     &                       CHF_CONST_INTVECT[bc_check_left],
     &                       CHF_CONST_INTVECT[bc_check_right],
     &                       CHF_CONST_REALVECT[left_edge],
     &                       CHF_CONST_REALVECT[right_edge],
     &                       CHF_CONST_REAL[slope],
     &                       CHF_CONST_REAL[slope_inv] )

      REAL_T xpold_save(0:CH_SPACEDIM - 1), xpnew_save(0:CH_SPACEDIM - 1)
      integer i0, i1

      i0 = 0
      i1 = CH_SPACEDIM - 1

      xpold_save = xpold
      xpnew_save = xpnew

c     check for bc particles in dir = i0  
      if( bc_check_left(i0)==1 ) then
        if(xpold(i0)<left_edge(i0)) then
          xpold(i0) = left_edge(i0)
          xpold(i1) = xpold_save(i1) + slope*(xpold(i0)-xpold_save(i0))
        endif
        if(xpnew(i0)<left_edge(i0)) then
          xpnew(i0) = left_edge(i0)
          xpnew(i1) = xpold_save(i1) + slope*(xpnew(i0)-xpold_save(i0))
        endif
      endif
      if( bc_check_right(i0)==1 ) then
        if(xpold(i0)>right_edge(i0)) then
          xpold(i0) = right_edge(i0)
          xpold(i1) = xpold_save(i1) + slope*(xpold(i0)-xpold_save(i0))
        endif
        if(xpnew(i0)>right_edge(i0)) then
          xpnew(i0) = right_edge(i0)
          xpnew(i1) = xpold_save(i1) + slope*(xpnew(i0)-xpold_save(i0))
        endif
      endif

c     check for bc particles in dir = i1  
      if( bc_check_left(i1)==1 ) then
        if(xpold(i1)<left_edge(i1)) then
          xpold(i1) = left_edge(i1)
          xpold(i0) = xpold_save(i0) + slope_inv*(xpold(i1)-xpold_save(i1))
        endif
        if(xpnew(i1)<left_edge(i1)) then
          xpnew(i1) = left_edge(i1)
          xpnew(i0) = xpold_save(i0) + slope_inv*(xpnew(i1)-xpold_save(i1))
        endif
      endif
      if( bc_check_right(i1)==1 ) then
        if(xpold(i1)>right_edge(i1)) then
          xpold(i1) = right_edge(i1)
          xpold(i0) = xpold_save(i0) + slope_inv*(xpold(i1)-xpold_save(i1))
        endif
        if(xpnew(i1)>right_edge(i1)) then
          xpnew(i1) = right_edge(i1)
          xpnew(i0) = xpold_save(i0) + slope_inv*(xpnew(i1)-xpold_save(i1))
        endif
      endif

      end

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
