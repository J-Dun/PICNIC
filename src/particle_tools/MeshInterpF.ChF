C      _______              __
C     / ___/ /  ___  __ _  / /  ___
C    / /__/ _ \/ _ \/  V \/ _ \/ _ \
C    \___/_//_/\___/_/_/_/_.__/\___/
C    Please refer to Copyright.txt, in Chombo's root directory.

c     Deposits a particle moment using nearest grid point interpolation
c     
c     Arguments:
c
c         moment:     the moment container onto which to deposit the particle moment
c         left_edge:  the physical location of the left edge of the domain
c         dx:         the mesh spacing
c         x:          the position coordinate of the particle
c         kernal:     the velocity-space kernal of the particle
c         q:          the particle weight
c
      subroutine moment_deposit( CHF_FRA1[moment],
     &                   CHF_CONST_REALVECT[left_edge],
     &                   CHF_CONST_REALVECT[dx],
     &                   CHF_CONST_REALVECT[x],
     &                   CHF_CONST_REAL[kernal],
     &                   CHF_CONST_REAL[q] ) 

      integer index(0:CH_SPACEDIM - 1)
      integer idir
      REAL_T volume 
      volume = CHF_DTERM[dx(0);*dx(1);*dx(2)]

c     compute the index of the cell containing this particle
      do idir = 0, CH_SPACEDIM - 1
        index(idir) = floor((x(idir) - left_edge(idir)) / dx(idir))
      enddo

c     assign the particle weight X kernal to that cell
      moment(CHF_IX[index(0); index(1); index(2)]) = 
     &   moment(CHF_IX[index(0); index(1); index(2)]) + q*kernal / volume

      end

ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      
      subroutine moment3v_deposit( CHF_FRA[energy],
     &                   CHF_CONST_REALVECT[left_edge],
     &                   CHF_CONST_REALVECT[dx],
     &                   CHF_CONST_REALVECT[x],
     &                   CHF_CONST_REAL[kernal0],
     &                   CHF_CONST_REAL[kernal1],
     &                   CHF_CONST_REAL[kernal2],
     &                   CHF_CONST_REAL[w] ) 

      integer index(0:CH_SPACEDIM - 1)
      integer idir
      REAL_T volume 
      volume = CHF_DTERM[dx(0);*dx(1);*dx(2)]

c     compute the index of the cell containing this particle
      do idir = 0, CH_SPACEDIM - 1
        index(idir) = floor((x(idir) - left_edge(idir)) / dx(idir))
      enddo

c     assign the particle weight X kernal to that cell
      energy(CHF_IX[index(0); index(1); index(2)],0) = 
     &   energy(CHF_IX[index(0); index(1); index(2)],0) + w*kernal0/volume
      
      energy(CHF_IX[index(0); index(1); index(2)],1) = 
     &   energy(CHF_IX[index(0); index(1); index(2)],1) + w*kernal1/volume
      
      energy(CHF_IX[index(0); index(1); index(2)],2) = 
     &   energy(CHF_IX[index(0); index(1); index(2)],2) + w*kernal2/volume

      end

ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

c     set the particle weights using grid profile for density
c     
c     Arguments:
c
c         moment:     the moment container onto which to deposit the particle moment
c         left_edge:  the physical location of the left edge of the domain
c         dx:         the mesh spacing
c         x:          the position coordinate of the particle

      subroutine set_particle_weight( 
     &                                CHF_REAL[weight], 
     &                                CHF_CONST_REAL[partsPerCell],
     &                                CHF_CONST_FRA1[density],
     &                                CHF_CONST_REALVECT[left_edge],
     &                                CHF_CONST_REALVECT[dx],
     &                                CHF_CONST_REALVECT[x] ) 

      integer index(0:CH_SPACEDIM - 1)
      integer idir
      REAL_T volume 
      volume = CHF_DTERM[dx(0);*dx(1);*dx(2)]

c     compute the index of the cell containing this particle
      do idir = 0, CH_SPACEDIM - 1
        index(idir) = floor((x(idir) - left_edge(idir)) / dx(idir))
      enddo

c     assign the particle weight
      weight = density(CHF_IX[index(0); index(1); index(2)])*volume/partsPerCell

      end

ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

c     Deposits a particle using nearest grid point interpolation
c     
c     Arguments:
c
c         rho:        the mesh onto which to deposit the particle
c         left_edge:  the physical location of the left edge of the domain
c         dx:         the mesh spacing
c         x:          the position coordinate of the particle
c         q:          the particle mass / charge
c
      subroutine ngp_deposit(
     &                       CHF_FRA1[rho],
     &                       CHF_CONST_REALVECT[left_edge],
     &                       CHF_CONST_REALVECT[dx],
     &                       CHF_CONST_REALVECT[x],
     &                       CHF_CONST_REAL[q]) 

      integer index(0:CH_SPACEDIM - 1)
      integer idir
      REAL_T volume 
      volume = CHF_DTERM[dx(0);*dx(1);*dx(2)]

c     compute the index of the cell containing this particle
      do idir = 0, CH_SPACEDIM - 1
        index(idir) = floor((x(idir) - left_edge(idir)) / dx(idir))
      enddo

c     assign the particle mass to that cell
      rho(CHF_IX[index(0); index(1); index(2)]) = 
     &   rho(CHF_IX[index(0); index(1); index(2)]) + q / volume

      end

c     Interpolates the field to the particle position using NGP interpolation.
c     
c     Arguments:
c
c         particle_field: the field interpolated to the particle position
c         field:          the field data stored on the mesh
c         left_edge:      the physical location of the left edge of the domain
c         dx:             the mesh spacing
c         x:              the position coordinate of the particle
c
      subroutine ngp_interpolate(
     &                           CHF_REALVECT[particle_field],
     &                           CHF_CONST_FRA[field],
     &                           CHF_CONST_REALVECT[left_edge],
     &                           CHF_CONST_REALVECT[dx],
     &                           CHF_CONST_REALVECT[x])

      integer index(0:CH_SPACEDIM - 1)
      integer idir

c     compute the index of the cell containing this particle
      do idir = 0, CH_SPACEDIM - 1
        index(idir) = floor((x(idir) - left_edge(idir)) / dx(idir))
      enddo

c     simply grab the value of the field at that location
      do idir = 0, CH_SPACEDIM - 1
        particle_field(idir) = field(CHF_IX[index(0); index(1); index(2)], idir)
      enddo

      end

c     Deposits a particle using cloud-in-cell interpolation
c     
c     Arguments:
c
c         rho:        the mesh onto which to deposit the particle
c         left_edge:  the physical location of the left edge of the domain
c         dx:         the mesh spacing
c         x:          the position coordinate of the particle
c         q:          the particle mass / charge
c
      subroutine cic_deposit(
     &                       CHF_FRA1[rho],
     &                       CHF_CONST_REALVECT[left_edge],
     &                       CHF_CONST_REALVECT[dx],
     &                       CHF_CONST_REALVECT[xp],
     &                       CHF_CONST_INTVECT[stag],
     &                       CHF_CONST_REAL[kernal], 
     &                       CHF_CONST_REAL[q]) 

      integer index(0:CH_SPACEDIM - 1)
      integer idir
      REAL_T volume, CHF_DDECL[l0;l1;l2]
      REAL_T particle_rho
      REAL_T weight, CHF_DDECL[w0;w1;w2]
      integer CHF_DDECL[ii;jj;kk]

c     compute the cell volume and particle density on the grid
      volume = CHF_DTERM[dx(0);*dx(1);*dx(2)]
      particle_rho = q / volume

c     compute the index of the cell that contains the LEFT edge of
c     this particle cloud.
      do idir = 0, CH_SPACEDIM - 1
        index(idir) = floor((xp(idir) - left_edge(idir) - 0.5d0*dx(idir)*(1.0-stag(idir))) / dx(idir))
      enddo

c     loop over all the cells containing this particle cloud,
c     computing weight and assigning mass
      CHF_DTERM[
      do ii = index(0), index(0) + 1
        l0 = ii*dx(0) + 0.5d0*dx(0)*(1.0-stag(0)) - xp(0) + left_edge(0)
        w0 = 1.d0 - abs(l0 / dx(0));
        do jj = index(1), index(1) + 1
          l1 = jj*dx(1) + 0.5d0*dx(1)*(1.0-stag(1)) - xp(1) + left_edge(1)
          w1 = 1.d0 - abs(l1 / dx(1));
          do kk = index(2), index(2) + 1
            l2 = kk*dx(2) + 0.5d0*dx(2)*(1.0-stag(2)) - xp(2) + left_edge(2)
            w2 = 1.d0 - abs(l2 / dx(2)) ]

            weight = CHF_DTERM[w0; *w1; *w2]

            rho(CHF_IX[ii; jj; kk]) = 
     &      rho(CHF_IX[ii; jj; kk]) + kernal * particle_rho * weight

      CHF_DTERM[
          enddo;
        enddo;
      enddo]

      end

c     Interpolates the field to the particle position using CIC interpolation.
c     
c     Arguments:
c
c         particle_field: the field interpolated to the particle position
c         field:          the field data stored on the mesh
c         left_edge:      the physical location of the left edge of the domain
c         dx:             the mesh spacing
c         x:              the position coordinate of the particle
c
      subroutine cic_interpolate(
     &                           CHF_REALVECT[particle_field],
     &                           CHF_CONST_FRA[field],
     &                           CHF_CONST_REALVECT[left_edge],
     &                           CHF_CONST_REALVECT[dx],
     &                           CHF_CONST_REALVECT[x])

      integer index(0:CH_SPACEDIM - 1)
      integer idir
      REAL_T CHF_DDECL[l0;l1;l2]
      REAL_T weight, CHF_DDECL[w0;w1;w2]
      integer CHF_DDECL[ii;jj;kk]

c     compute the index of the cell that contains the LEFT edge of
c     this particle cloud.
      do idir = 0, CH_SPACEDIM - 1
        index(idir) = floor((x(idir) - left_edge(idir) - 0.5d0*dx(idir)) / dx(idir))
      enddo

c     loop over all the cells containing this particle cloud,
c     computing weight and incrementing the force
      CHF_DTERM[
      do ii = index(0), index(0) + 1
        l0 = ii*dx(0) + 0.5d0*dx(0) - x(0) + left_edge(0);
        do jj = index(1), index(1) + 1
          l1 = jj*dx(1) + 0.5d0*dx(1) - x(1) + left_edge(1);
          do kk = index(2), index(2) + 1
            l2 = kk*dx(2) + 0.5d0*dx(2) - x(2) + left_edge(2)]

            CHF_DTERM[ 
            w0 = 1.d0 - abs(l0 / dx(0));
            w1 = 1.d0 - abs(l1 / dx(1));
            w2 = 1.d0 - abs(l2 / dx(2))]

            weight = CHF_DTERM[w0; *w1; *w2]

            do idir = 0, CH_SPACEDIM - 1

              particle_field(idir) = particle_field(idir) + 
     &                 weight * field(CHF_IX[ii; jj; kk], idir)

            enddo

      CHF_DTERM[
          enddo;
        enddo;
      enddo]

      end

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c  Deposits particle current density using cloud-in-cell interpolation
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine cic_deposit_current(
     &                       CHF_FRA1[rhoVx],
     &                       CHF_FRA1[rhoVy],
     &                       CHF_FRA1[rhoVz],
     &                       CHF_CONST_REALVECT[left_edge],
     &                       CHF_CONST_REALVECT[dx],
     &                       CHF_CONST_REALVECT[xp],
     &                       CHF_CONST_REAL[vpx], 
     &                       CHF_CONST_REAL[vpy], 
     &                       CHF_CONST_REAL[vpz], 
     &                       CHF_CONST_REAL[qp]) 

      integer index(0:CH_SPACEDIM - 1), index_stag(0:CH_SPACEDIM -1)
      integer CHF_DDECL[ii;jj;kk], CHF_DDECL[ii_stag;jj_stag;kk_stag]
      integer idir
      REAL_T CHF_DDECL[l0;l1;l2], CHF_DDECL[l0_stag;l1_stag;l2_stag]
      REAL_T CHF_DDECL[w0;w1;w2], CHF_DDECL[w0_stag;w1_stag;w2_stag]
      REAL_T volume, rhop, weight

c     compute the cell volume and particle density on the grid
      volume = CHF_DTERM[dx(0);*dx(1);*dx(2)]
      rhop = qp / volume

c     compute the index of the left most cell/edge that contains this particle cloud
      do idir = 0, CH_SPACEDIM - 1
        index(idir) = floor((xp(idir) - left_edge(idir) - 0.5d0*dx(idir)) / dx(idir))
        index_stag(idir) = floor((xp(idir) - left_edge(idir)) / dx(idir))
      enddo

c     loop over all the cells containing this cloud and deposit the current
      CHF_DTERM[
      do ii = index(0), index(0) + 1
        l0 = ii*dx(0) + 0.5d0*dx(0) - xp(0) + left_edge(0)
        ii_stag = ii-index(0)+index_stag(0)
        l0_stag = ii_stag*dx(0) - xp(0) + left_edge(0)
        w0 = 1.d0 - abs(l0 / dx(0))
        w0_stag = 1.d0 - abs(l0_stag / dx(0));
        do jj = index(1), index(1) + 1
          l1 = jj*dx(1) + 0.5d0*dx(1) - xp(1) + left_edge(1)
          jj_stag = jj-index(1)+index_stag(1)
          l1_stag = jj_stag*dx(1) - xp(1) + left_edge(1)
          w1 = 1.d0 - abs(l1 / dx(1))
          w1_stag = 1.d0 - abs(l1_stag / dx(1));
          do kk = index(2), index(2) + 1
            l2 = kk*dx(2) + 0.5d0*dx(2) - xp(2) + left_edge(2)
            kk_stag = kk-index(2)+index_stag(2)
            l2_stag = kk_stag*dx(2) - xp(2) + left_edge(2)
            w2 = 1.d0 - abs(l2 / dx(2))
            w2_stag = 1.d0 - abs(l2_stag / dx(2)) ]

            weight = CHF_DTERM[w0; *w1_stag; *w2_stag]
            rhoVx(CHF_IX[ii; jj_stag; kk_stag]) = 
     &      rhoVx(CHF_IX[ii; jj_stag; kk_stag]) + vpx * rhop * weight
            
            weight = CHF_DTERM[w0_stag; *w1; *w2_stag]
            rhoVy(CHF_IX[ii_stag; jj; kk_stag]) = 
     &      rhoVy(CHF_IX[ii_stag; jj; kk_stag]) + vpy * rhop * weight
            
            weight = CHF_DTERM[w0_stag; *w1_stag; *w2]
            rhoVz(CHF_IX[ii_stag; jj_stag; kk]) = 
     &      rhoVz(CHF_IX[ii_stag; jj_stag; kk]) + vpz * rhop * weight

      CHF_DTERM[
          enddo;
        enddo;
      enddo]

      end

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c  Deposits particle current density using triangular-shaped cloud interpolation
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine tsc_deposit_current(
     &                       CHF_FRA1[rhoVx],
     &                       CHF_FRA1[rhoVy],
     &                       CHF_FRA1[rhoVz],
     &                       CHF_CONST_REALVECT[left_edge],
     &                       CHF_CONST_REALVECT[dx],
     &                       CHF_CONST_REALVECT[xp],
     &                       CHF_CONST_REAL[vpx], 
     &                       CHF_CONST_REAL[vpy], 
     &                       CHF_CONST_REAL[vpz], 
     &                       CHF_CONST_REAL[qp]) 

      integer index(0:CH_SPACEDIM - 1), index_stag(0:CH_SPACEDIM -1)
      integer CHF_DDECL[ii;jj;kk], CHF_DDECL[ii_stag;jj_stag;kk_stag]
      integer idir
      REAL_T CHF_DDECL[l0;l1;l2], CHF_DDECL[l0_stag;l1_stag;l2_stag]
      REAL_T CHF_DDECL[w0;w1;w2], CHF_DDECL[w0_stag;w1_stag;w2_stag]
      REAL_T volume, rhop, weight

c     compute the cell volume and particle density on the grid
      volume = CHF_DTERM[dx(0);*dx(1);*dx(2)]
      rhop = qp / volume

c     compute the index of the left most cell/edge that contains this particle cloud
      do idir = 0, CH_SPACEDIM - 1
        index(idir) = floor((xp(idir) - left_edge(idir) - dx(idir)) / dx(idir))
        index_stag(idir) = floor((xp(idir) - left_edge(idir) - 0.5d0*dx(idir)) / dx(idir))
      enddo

c     loop over all the cells containing this cloud and deposit the current
      CHF_DTERM[
      do ii = index(0), index(0) + 2
        l0 = ii*dx(0) + 0.5d0*dx(0) - xp(0) + left_edge(0)
        if (abs(l0 / dx(0)) .lt. 0.5d0) then 
          w0 = 0.75d0 - (l0 / dx(0))**2.d0
        else
          w0 = 0.5d0 * (1.5d0 - abs(l0 / dx(0)))**2.d0 
        endif
        ii_stag = ii-index(0)+index_stag(0)
        l0_stag = ii_stag*dx(0) - xp(0) + left_edge(0)
        if (abs(l0_stag / dx(0)) .lt. 0.5d0) then 
          w0_stag = 0.75d0 - (l0_stag / dx(0))**2.d0
        else
          w0_stag = 0.5d0 * (1.5d0 - abs(l0_stag / dx(0)))**2.d0 
        endif;
        do jj = index(1), index(1) + 2
          l1 = jj*dx(1) + 0.5d0*dx(1) - xp(1) + left_edge(1)
          if (abs(l1 / dx(1)) .lt. 0.5d0) then 
            w1 = 0.75d0 - (l1 / dx(1))**2.d0
          else
            w1 = 0.5d0 * (1.5d0 - abs(l1 / dx(1)))**2.d0 
          endif
          jj_stag = jj-index(1)+index_stag(1)
          l1_stag = jj_stag*dx(1) - xp(1) + left_edge(1)
          if (abs(l1_stag / dx(1)) .lt. 0.5d0) then 
            w1_stag = 0.75d0 - (l1_stag / dx(1))**2.d0
          else
            w1_stag = 0.5d0 * (1.5d0 - abs(l1_stag / dx(1)))**2.d0 
          endif;
          do kk = index(2), index(2) + 2
            l2 = kk*dx(2) + 0.5d0*dx(2) - xp(2) + left_edge(2)
            if (abs(l2 / dx(2)) .lt. 0.5d0) then 
              w2 = 0.75d0 - (l2 / dx(2))**2.d0
            else
              w2 = 0.5d0 * (1.5d0 - abs(l2 / dx(2)))**2.d0 
            endif
            kk_stag = kk-index(2)+index_stag(2)
            l2_stag = kk_stag*dx(2) - xp(2) + left_edge(2)
            if (abs(l2_stag / dx(2)) .lt. 0.5d0) then 
              w2_stag = 0.75d0 - (l2_stag / dx(2))**2.d0
            else
              w2_stag = 0.5d0 * (1.5d0 - abs(l2_stag / dx(2)))**2.d0 
            endif ]

            weight = CHF_DTERM[w0; *w1_stag; *w2_stag]
            rhoVx(CHF_IX[ii; jj_stag; kk_stag]) = 
     &      rhoVx(CHF_IX[ii; jj_stag; kk_stag]) + vpx * rhop * weight
            
            weight = CHF_DTERM[w0_stag; *w1; *w2_stag]
            rhoVy(CHF_IX[ii_stag; jj; kk_stag]) = 
     &      rhoVy(CHF_IX[ii_stag; jj; kk_stag]) + vpy * rhop * weight
            
            weight = CHF_DTERM[w0_stag; *w1_stag; *w2]
            rhoVz(CHF_IX[ii_stag; jj_stag; kk]) = 
     &      rhoVz(CHF_IX[ii_stag; jj_stag; kk]) + vpz * rhop * weight

      CHF_DTERM[
          enddo;
        enddo;
      enddo]

      end

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c  Interpolates EM fields to the particle position using CIC interpolation.
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine cic_interpolate_fields( CHF_REAL[Epx],
     &                                   CHF_REAL[Epy],
     &                                   CHF_REAL[Epz],
     &                                   CHF_REAL[Bpx],
     &                                   CHF_REAL[Bpy],
     &                                   CHF_REAL[Bpz],
     &                                   CHF_CONST_FRA1[Ex],
     &                                   CHF_CONST_FRA1[Ey],
     &                                   CHF_CONST_FRA1[Ez],
     &                                   CHF_CONST_FRA1[Bx],
     &                                   CHF_CONST_FRA1[By],
     &                                   CHF_CONST_FRA1[Bz],
     &                                   CHF_CONST_REALVECT[left_edge],
     &                                   CHF_CONST_REALVECT[dx],
     &                                   CHF_CONST_REALVECT[xp] )

      integer index(0:CH_SPACEDIM - 1), index_stag(0:CH_SPACEDIM - 1)
      integer CHF_DDECL[ii;jj;kk], CHF_DDECL[ii_stag;jj_stag;kk_stag]
      integer idir
      REAL_T CHF_DDECL[l0;l1;l2], CHF_DDECL[l0_stag;l1_stag;l2_stag]
      REAL_T weight, CHF_DDECL[w0;w1;w2], CHF_DDECL[w0_stag;w1_stag;w2_stag]

c     compute the index of the left most cell/edge that contains this particle cloud
      do idir = 0, CH_SPACEDIM - 1
        index(idir) = floor((xp(idir) - left_edge(idir) - 0.5d0*dx(idir)) / dx(idir))
        index_stag(idir) = floor((xp(idir) - left_edge(idir)) / dx(idir))
      enddo

c     loop over all the cells containing this particle cloud and add to field
      CHF_DTERM[
      do ii = index(0), index(0) + 1
        l0 = ii*dx(0) + 0.5d0*dx(0) - xp(0) + left_edge(0)
        ii_stag = ii-index(0)+index_stag(0)
        l0_stag = ii_stag*dx(0) - xp(0) + left_edge(0)
        w0 = 1.d0 - abs(l0 / dx(0))
        w0_stag = 1.d0 - abs(l0_stag / dx(0));
        do jj = index(1), index(1) + 1
          l1 = jj*dx(1) + 0.5d0*dx(1) - xp(1) + left_edge(1)
          jj_stag = jj-index(1)+index_stag(1)
          l1_stag = jj_stag*dx(1) - xp(1) + left_edge(1)
          w1 = 1.d0 - abs(l1 / dx(1))
          w1_stag = 1.d0 - abs(l1_stag / dx(1));
          do kk = index(2), index(2) + 1
            l2 = kk*dx(2) + 0.5d0*dx(2) - xp(2) + left_edge(2)
            kk_stag = kk-index(2)+index_stag(2)
            l2_stag = kk_stag*dx(2) - xp(2) + left_edge(2)
            w2 = 1.d0 - abs(l2 / dx(2))
            w2_stag = 1.d0 - abs(l2_stag / dx(2)) ]

            weight = CHF_DTERM[w0; *w1_stag; *w2_stag]
            Epx = Epx + weight*Ex(CHF_IX[ii; jj_stag; kk_stag])
            
            weight = CHF_DTERM[w0_stag; *w1; *w2_stag]
            Epy = Epy + weight*Ey(CHF_IX[ii_stag; jj; kk_stag])
            
            weight = CHF_DTERM[w0_stag; *w1_stag; *w2]
            Epz = Epz + weight*Ez(CHF_IX[ii_stag; jj_stag; kk])
            
            weight = CHF_DTERM[w0_stag; *w1; *w2]
            Bpx = Bpx + weight*Bx(CHF_IX[ii_stag; jj; kk])
            
            weight = CHF_DTERM[w0; *w1_stag; *w2]
            Bpy = Bpy + weight*By(CHF_IX[ii; jj_stag; kk])
            
            weight = CHF_DTERM[w0; *w1; *w2_stag]
            Bpz = Bpz + weight*Bz(CHF_IX[ii; jj; kk_stag])

      CHF_DTERM[
          enddo;
        enddo;
      enddo]

      end

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c  Interpolates EM fields to the particle position using TSC interpolation.
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine tsc_interpolate_fields( CHF_REAL[Epx],
     &                                   CHF_REAL[Epy],
     &                                   CHF_REAL[Epz],
     &                                   CHF_REAL[Bpx],
     &                                   CHF_REAL[Bpy],
     &                                   CHF_REAL[Bpz],
     &                                   CHF_CONST_FRA1[Ex],
     &                                   CHF_CONST_FRA1[Ey],
     &                                   CHF_CONST_FRA1[Ez],
     &                                   CHF_CONST_FRA1[Bx],
     &                                   CHF_CONST_FRA1[By],
     &                                   CHF_CONST_FRA1[Bz],
     &                                   CHF_CONST_REALVECT[left_edge],
     &                                   CHF_CONST_REALVECT[dx],
     &                                   CHF_CONST_REALVECT[xp] )

      integer index(0:CH_SPACEDIM - 1), index_stag(0:CH_SPACEDIM - 1)
      integer CHF_DDECL[ii;jj;kk], CHF_DDECL[ii_stag;jj_stag;kk_stag]
      integer idir
      REAL_T CHF_DDECL[l0;l1;l2], CHF_DDECL[l0_stag;l1_stag;l2_stag]
      REAL_T weight, CHF_DDECL[w0;w1;w2], CHF_DDECL[w0_stag;w1_stag;w2_stag]

c     compute the index of the left most cell/edge that contains this particle cloud
      do idir = 0, CH_SPACEDIM - 1
        index(idir) = floor((xp(idir) - left_edge(idir) - dx(idir)) / dx(idir))
        index_stag(idir) = floor((xp(idir) - left_edge(idir) - 0.5d0*dx(idir)) / dx(idir))
      enddo

c     loop over all the cells containing this particle cloud and add to field
      CHF_DTERM[
      do ii = index(0), index(0) + 2
        l0 = ii*dx(0) + 0.5d0*dx(0) - xp(0) + left_edge(0)
        if (abs(l0 / dx(0)) .lt. 0.5d0) then 
          w0 = 0.75d0 - (l0 / dx(0))**2.d0
        else
          w0 = 0.5d0 * (1.5d0 - abs(l0 / dx(0)))**2.d0 
        endif
        ii_stag = ii-index(0)+index_stag(0)
        l0_stag = ii_stag*dx(0) - xp(0) + left_edge(0)
        if (abs(l0_stag / dx(0)) .lt. 0.5d0) then 
          w0_stag = 0.75d0 - (l0_stag / dx(0))**2.d0
        else
          w0_stag = 0.5d0 * (1.5d0 - abs(l0_stag / dx(0)))**2.d0
        endif;
        do jj = index(1), index(1) + 2
          l1 = jj*dx(1) + 0.5d0*dx(1) - xp(1) + left_edge(1)
          if (abs(l1 / dx(1)) .lt. 0.5d0) then 
            w1 = 0.75d0 - (l1 / dx(1))**2.d0
          else
            w1 = 0.5d0 * (1.5d0 - abs(l1 / dx(1)))**2.d0 
          endif
          jj_stag = jj-index(1)+index_stag(1)
          l1_stag = jj_stag*dx(1) - xp(1) + left_edge(1)
          if (abs(l1_stag / dx(1)) .lt. 0.5d0) then 
            w1_stag = 0.75d0 - (l1_stag / dx(1))**2.d0
          else
            w1_stag = 0.5d0 * (1.5d0 - abs(l1_stag / dx(1)))**2.d0 
          endif;
          do kk = index(2), index(2) + 2
            l2 = kk*dx(2) + 0.5d0*dx(2) - xp(2) + left_edge(2)
            if (abs(l2 / dx(2)) .lt. 0.5d0) then 
              w2 = 0.75d0 - (l2 / dx(2))**2.d0
            else
              w2 = 0.5d0 * (1.5d0 - abs(l2 / dx(2)))**2.d0 
            endif
            kk_stag = kk-index(2)+index_stag(2)
            l2_stag = kk_stag*dx(2) - xp(2) + left_edge(2)
            if (abs(l2_stag / dx(2)) .lt. 0.5d0) then 
              w2_stag = 0.75d0 - (l2_stag / dx(2))**2.d0
            else
              w2_stag = 0.5d0 * (1.5d0 - abs(l2_stag / dx(2)))**2.d0 
            endif ]

            weight = CHF_DTERM[w0; *w1_stag; *w2_stag]
            Epx = Epx + weight*Ex(CHF_IX[ii; jj_stag; kk_stag])
            
            weight = CHF_DTERM[w0_stag; *w1; *w2_stag]
            Epy = Epy + weight*Ey(CHF_IX[ii_stag; jj; kk_stag])
            
            weight = CHF_DTERM[w0_stag; *w1_stag; *w2]
            Epz = Epz + weight*Ez(CHF_IX[ii_stag; jj_stag; kk])
            
            weight = CHF_DTERM[w0_stag; *w1; *w2]
            Bpx = Bpx + weight*Bx(CHF_IX[ii_stag; jj; kk])
            
            weight = CHF_DTERM[w0; *w1_stag; *w2]
            Bpy = Bpy + weight*By(CHF_IX[ii; jj_stag; kk])
            
            weight = CHF_DTERM[w0; *w1; *w2_stag]
            Bpz = Bpz + weight*Bz(CHF_IX[ii; jj; kk_stag])

      CHF_DTERM[
          enddo;
        enddo;
      enddo]

      end

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c  Interpolates magnetic field to the particle position using CIC interpolation.
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

      subroutine cic_interpolate_magnetic_field( CHF_REAL[Bpx],
     &                                           CHF_REAL[Bpy],
     &                                           CHF_REAL[Bpz],
     &                                           CHF_CONST_FRA1[Bgx],
     &                                           CHF_CONST_FRA1[Bgy],
     &                                           CHF_CONST_FRA1[Bgz],
     &                                           CHF_CONST_REALVECT[left_edge],
     &                                           CHF_CONST_REALVECT[dx],
     &                                           CHF_CONST_REALVECT[xp] )

      integer index(0:CH_SPACEDIM - 1), index_stag(0:CH_SPACEDIM - 1)
      integer CHF_DDECL[ii;jj;kk], CHF_DDECL[ii_stag;jj_stag;kk_stag]
      integer idir
      REAL_T CHF_DDECL[l0;l1;l2], CHF_DDECL[l0_stag;l1_stag;l2_stag]
      REAL_T weight, CHF_DDECL[w0;w1;w2], CHF_DDECL[w0_stag;w1_stag;w2_stag]

c     compute the index of the left most cell/edge that contains this particle cloud
      do idir = 0, CH_SPACEDIM - 1
        index(idir) = floor((xp(idir) - left_edge(idir) - 0.5d0*dx(idir)) / dx(idir))
        index_stag(idir) = floor((xp(idir) - left_edge(idir)) / dx(idir))
      enddo

      CHF_DTERM[
      do ii = index(0), index(0) + 1
        l0 = ii*dx(0) + 0.5d0*dx(0) - xp(0) + left_edge(0)
        ii_stag = ii-index(0)+index_stag(0)
        l0_stag = ii_stag*dx(0) - xp(0) + left_edge(0)
        w0 = 1.d0 - abs(l0 / dx(0))
        w0_stag = 1.d0 - abs(l0_stag / dx(0));
        do jj = index(1), index(1) + 1
          l1 = jj*dx(1) + 0.5d0*dx(1) - xp(1) + left_edge(1)
          jj_stag = jj-index(1)+index_stag(1)
          l1_stag = jj_stag*dx(1) - xp(1) + left_edge(1)
          w1 = 1.d0 - abs(l1 / dx(1))
          w1_stag = 1.d0 - abs(l1_stag / dx(1));
          do kk = index(2), index(2) + 1
            l2 = kk*dx(2) + 0.5d0*dx(2) - xp(2) + left_edge(2)
            kk_stag = kk-index(2)+index_stag(2)
            l2_stag = kk_stag*dx(2) - xp(2) + left_edge(2)
            w2 = 1.d0 - abs(l2 / dx(2))
            w2_stag = 1.d0 - abs(l2_stag / dx(2)) ]

            weight = CHF_DTERM[w0_stag; *w1; *w2]
            Bpx = Bpx + weight*Bgx(CHF_IX[ii_stag; jj; kk])
            
            weight = CHF_DTERM[w0; *w1_stag; *w2]
            Bpy = Bpy + weight*Bgy(CHF_IX[ii; jj_stag; kk])
            
            weight = CHF_DTERM[w0; *w1; *w2_stag]
            Bpz = Bpz + weight*Bgz(CHF_IX[ii; jj; kk_stag])

      CHF_DTERM[
          enddo;
        enddo;
      enddo]

      end

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

c     Interpolates the field to the particle position using CIC interpolation.
c     
c     Arguments:
c
c         particle_field: the field interpolated to the particle position
c         field:          the field data stored on the mesh
c         left_edge:      the physical location of the left edge of the domain
c         dx:             the mesh spacing
c         x:              the position coordinate of the particle
c
      subroutine cic_interpolate_dir( CHF_REAL[particle_field],
     &                                CHF_CONST_FRA1[field],
     &                                CHF_CONST_REALVECT[left_edge],
     &                                CHF_CONST_REALVECT[dx],
     &                                CHF_CONST_REALVECT[xp],
     &                                CHF_CONST_INTVECT[stag] )

      integer index(0:CH_SPACEDIM - 1), CHF_DDECL[ii;jj;kk], idir
      REAL_T CHF_DDECL[l0;l1;l2]
      REAL_T weight, CHF_DDECL[w0;w1;w2]

c     compute the index of the cell that contains the LEFT edge of
c     this particle cloud.
      do idir = 0, CH_SPACEDIM - 1
        index(idir) = floor((xp(idir) - left_edge(idir) - 0.5d0*dx(idir)*(1.0-stag(idir))) / dx(idir))
      enddo

c     loop over all the cells containing this particle cloud,
c     computing weight and incrementing the force
      CHF_DTERM[
      do ii = index(0), index(0) + 1
        l0 = ii*dx(0) + 0.5d0*dx(0)*(1.0-stag(0)) - xp(0) + left_edge(0)
        w0 = 1.d0 - abs(l0 / dx(0));
        do jj = index(1), index(1) + 1
          l1 = jj*dx(1) + 0.5d0*dx(1)*(1.0-stag(1)) - xp(1) + left_edge(1)
          w1 = 1.d0 - abs(l1 / dx(1));
          do kk = index(2), index(2) + 1
            l2 = kk*dx(2) + 0.5d0*dx(2)*(1.0-stag(2)) - xp(2) + left_edge(2)
            w2 = 1.d0 - abs(l2 / dx(2)) ]

            weight = CHF_DTERM[w0; *w1; *w2]
            particle_field = particle_field + weight*field(CHF_IX[ii; jj; kk])

      CHF_DTERM[
          enddo;
        enddo;
      enddo]

      end

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc

c     Deposits a particle using triangle-shaped cloud interpolation
c     
c     Arguments:
c
c         rho:        the mesh onto which to deposit the particle
c         left_edge:  the physical location of the left edge of the domain
c         dx:         the mesh spacing
c         x:          the position coordinate of the particle
c         q:          the particle mass / charge
c
      subroutine tsc_deposit(
     &                       CHF_FRA1[rho],
     &                       CHF_CONST_REALVECT[left_edge],
     &                       CHF_CONST_REALVECT[dx],
     &                       CHF_CONST_REALVECT[xp],
     &                       CHF_CONST_INTVECT[stag],
     &                       CHF_CONST_REAL[kernal], 
     &                       CHF_CONST_REAL[q]) 

      integer index(0:CH_SPACEDIM - 1)
      integer idir
      REAL_T volume, CHF_DDECL[l0;l1;l2]
      REAL_T particle_rho
      REAL_T weight, CHF_DDECL[w0;w1;w2]
      integer CHF_DDECL[ii;jj;kk]

c     compute the cell volume and particle density on the grid
      volume = CHF_DTERM[dx(0);*dx(1);*dx(2)]
      particle_rho = q / volume

c     compute the index of the cell that contains the LEFT edge of
c     this particle cloud.
      do idir = 0, CH_SPACEDIM - 1
        index(idir) = floor((xp(idir) - left_edge(idir) - 0.5d0*dx(idir) - 0.5d0*dx(idir)*(1.0-stag(idir))) / dx(idir))
      enddo

c     loop over all the cells containing this particle cloud,
c     computing weight and assigning mass
      CHF_DTERM[
      do ii = index(0), index(0) + 2
        l0 = ii*dx(0) + 0.5d0*dx(0)*(1.0-stag(0)) - xp(0) + left_edge(0)
        if (abs(l0 / dx(0)) .lt. 0.5d0) then 
          w0 = 0.75d0 - (l0 / dx(0))**2.d0
        else
          w0 = 0.5d0 * (1.5d0 - abs(l0 / dx(0)))**2.d0 
        endif;
        do jj = index(1), index(1) + 2
          l1 = jj*dx(1) + 0.5d0*dx(1)*(1.0-stag(1)) - xp(1) + left_edge(1)
          if (abs(l1 / dx(1)) .lt. 0.5d0) then 
            w1 = 0.75d0 - (l1 / dx(1))**2.d0
          else
            w1 = 0.5d0 * (1.5d0 - abs(l1 / dx(1)))**2.d0 
          endif;
          do kk = index(2), index(2) + 2
            l2 = kk*dx(2) + 0.5d0*dx(2)*(1.0-stag(2)) - xp(2) + left_edge(2)
            if (abs(l2 / dx(2)) .lt. 0.5d0) then 
              w2 = 0.75d0 - (l2 / dx(2))**2.d0
            else
              w2 = 0.5d0 * (1.5d0 - abs(l2 / dx(2)))**2.d0 
            endif ]

            weight = CHF_DTERM[w0; *w1; *w2]

            rho(CHF_IX[ii; jj; kk]) = 
     &      rho(CHF_IX[ii; jj; kk]) + kernal * particle_rho * weight

      CHF_DTERM[
          enddo;
        enddo;
      enddo]

      end

c     Interpolates the field to the particle position using TSC interpolation
c     
c     Arguments:
c
c         particle_field: the field interpolated to the particle position
c         field:          the field data stored on the mesh
c         left_edge:      the physical location of the left edge of the domain
c         dx:             the mesh spacing
c         x:              the position coordinate of the particle
c
      subroutine tsc_interpolate(
     &                           CHF_REALVECT[particle_field],
     &                           CHF_CONST_FRA[field],
     &                           CHF_CONST_REALVECT[left_edge],
     &                           CHF_CONST_REALVECT[dx],
     &                           CHF_CONST_REALVECT[x])

      integer index(0:CH_SPACEDIM - 1)
      integer idir
      REAL_T volume, CHF_DDECL[l0;l1;l2;l3;l4;l5]
      REAL_T weight, CHF_DDECL[w0;w1;w2;w3;w4;w5]
      integer CHF_DDECL[ii;jj;kk;ll;mm;nn]

c     compute the index of the cell that contains the LEFT edge of
c     this particle cloud.
      do idir = 0, CH_SPACEDIM - 1
        index(idir) = floor((x(idir) - left_edge(idir) - 1.0d0*dx(idir)) / dx(idir))
      enddo

c     loop over all the cells containing this particle cloud,
c     computing weight and assigning mass
      CHF_DTERM[
      do ii = index(0), index(0) + 2
        l0 = ii*dx(0) + 0.5d0*dx(0) - x(0) + left_edge(0);
        do jj = index(1), index(1) + 2
          l1 = jj*dx(1) + 0.5d0*dx(1) - x(1) + left_edge(1);
          do kk = index(2), index(2) + 2
            l2 = kk*dx(2) + 0.5d0*dx(2) - x(2) + left_edge(2);
            do ll = index(3), index(3) + 2
              l3 = ll*dx(3) + 0.5d0*dx(3) - x(3) + left_edge(3);
              do mm = index(4), index(4) + 2
                l4 = mm*dx(4) + 0.5d0*dx(4) - x(4) + left_edge(4);
                do nn = index(5), index(5) + 2
                  l5 = nn*dx(5) + 0.5d0*dx(5) - x(5) + left_edge(5)]

            CHF_DTERM[
            if (abs(l0 / dx(0)) .lt. 0.5d0) then 
              w0 = 7.5d-1 - (l0 / dx(0))**2.d0
            else
              w0 = 0.5d0 * (1.5d0 - abs(l0 / dx(0)))**2.d0 
            endif
            ;
            if (abs(l1 / dx(1)) .lt. 0.5d0) then 
              w1 = 7.5d-1 - (l1 / dx(1))**2.d0
            else
              w1 = 0.5d0 * (1.5d0 - abs(l1 / dx(1)))**2.d0 
            endif
            ;
            if (abs(l2 / dx(2)) .lt. 0.5d0) then 
              w2 = 7.5d-1 - (l2 / dx(2))**2.d0
            else
              w2 = 0.5d0 * (1.5d0 - abs(l2 / dx(2)))**2.d0 
            endif
            ;
            if (abs(l3 / dx(3)) .lt. 0.5d0) then 
              w3 = 7.5d-1 - (l3 / dx(3))**2.d0
            else
              w3 = 0.5d0 * (1.5d0 - abs(l3 / dx(3)))**2.d0 
            endif
            ;
            if (abs(l4 / dx(4)) .lt. 0.5d0) then 
              w4 = 7.5d-1 - (l4 / dx(4))**2.d0
            else
              w4 = 0.5d0 * (1.5d0 - abs(l4 / dx(4)))**2.d0 
            endif
            ;
            if (abs(l5 / dx(5)) .lt. 0.5d0) then 
              w5 = 7.5d-1 - (l5 / dx(5))**2.d0
            else
              w5 = 0.5d0 * (1.5d0 - abs(l5 / dx(5)))**2.d0 
            endif                                    
            ]

            weight = CHF_DTERM[w0; *w1; *w2; *w3; *w4; *w5]

            do idir = 0, CH_SPACEDIM - 1

              particle_field(idir) = particle_field(idir) + 
     &                 weight * field(CHF_IX[ii; jj; kk; ll; mm; nn], idir)

            enddo

      CHF_DTERM[
                enddo;
              enddo;
            enddo;
          enddo;
        enddo;
      enddo]

      end


c     Deposits a particle using the 3rd order interpolation function
c     from Wang, Miller, and Colella 2010
c     
c     Arguments:
c
c         rho:        the mesh onto which to deposit the particle
c         left_edge:  the physical location of the left edge of the domain
c         dx:         the mesh spacing
c         x:          the position coordinate of the particle
c         q:          the particle mass / charge
c
      subroutine w4_deposit(
     &                      CHF_FRA1[rho],
     &                      CHF_CONST_REALVECT[left_edge],
     &                      CHF_CONST_REALVECT[dx],
     &                      CHF_CONST_REALVECT[x],
     &                      CHF_CONST_REAL[q]) 

      integer index(0:CH_SPACEDIM - 1)
      integer idir
      REAL_T volume, CHF_DDECL[l0;l1;l2;l3;l4;l5]
      REAL_T particle_rho
      REAL_T weight, CHF_DDECL[w0;w1;w2;w3;w4;w5]
      integer CHF_DDECL[ii;jj;kk;ll;mm;nn]

c     compute the cell volume and particle density on the grid
      volume = CHF_DTERM[dx(0);*dx(1);*dx(2);*dx(3);*dx(4);*dx(5)]
      particle_rho = q / volume

c     compute the index of the cell that contains the LEFT edge of
c     this particle cloud.
      do idir = 0, CH_SPACEDIM - 1
        index(idir) = floor((x(idir) - left_edge(idir) - 1.5d0*dx(idir)) / dx(idir))
      enddo

c     loop over all the cells containing this particle cloud,
c     computing weight and assigning mass
      CHF_DTERM[
      do ii = index(0), index(0) + 3
        l0 = ii*dx(0) + 0.5d0*dx(0) - x(0) + left_edge(0);
        do jj = index(1), index(1) + 3
          l1 = jj*dx(1) + 0.5d0*dx(1) - x(1) + left_edge(1);
          do kk = index(2), index(2) + 3
            l2 = kk*dx(2) + 0.5d0*dx(2) - x(2) + left_edge(2);
            do ll = index(3), index(3) + 3
              l3 = ll*dx(3) + 0.5d0*dx(3) - x(3) + left_edge(3);
              do mm = index(4), index(4) + 3
                l4 = mm*dx(4) + 0.5d0*dx(4) - x(4) + left_edge(4);
                do nn = index(5), index(5) + 3
                  l5 = nn*dx(5) + 0.5d0*dx(5) - x(5) + left_edge(5)]

            CHF_DTERM[
            if (abs(l0 / dx(0)) .lt. 1.d0) then 
              w0 = 1.d0 - 5.d0*abs(l0 / dx(0))**2.d0 / 2.d0 + 3.d0*abs(l0 / dx(0))**3.d0 / 2.d0
            else
              w0 = 0.5d0 * (2.0d0 - abs(l0 / dx(0)))**2.d0 * (1.d0 - abs(l0 / dx(0)))
            endif
            ;
            if (abs(l1 / dx(1)) .lt. 1.d0) then 
              w1 = 1.d0 - 5.d0*abs(l1 / dx(1))**2.d0 / 2.d0 + 3.d0*abs(l1 / dx(1))**3.d0 / 2.d0
            else
              w1 = 0.5d0 * (2.0d0 - abs(l1 / dx(1)))**2.d0 * (1.d0 - abs(l1 / dx(1))) 
            endif
            ;
            if (abs(l2 / dx(2)) .lt. 1.d0) then 
              w2 = 1.d0 - 5.d0*abs(l2 / dx(2))**2.d0 / 2.d0 + 3.d0*abs(l2 / dx(2))**3.d0 / 2.d0
            else
              w2 = 0.5d0 * (2.0d0 - abs(l2 / dx(2)))**2.d0 * (1.d0 - abs(l2 / dx(2)))
            endif
            ;
            if (abs(l3 / dx(3)) .lt. 1.d0) then 
              w3 = 1.d0 - 5.d0*abs(l3 / dx(3))**2.d0 / 2.d0 + 3.d0*abs(l3 / dx(3))**3.d0 / 2.d0
            else
              w3 = 0.5d0 * (2.0d0 - abs(l3 / dx(3)))**2.d0 * (1.d0 - abs(l3 / dx(3)))
            endif
            ;
            if (abs(l4 / dx(4)) .lt. 1.d0) then 
              w4 = 1.d0 - 5.d0*abs(l4 / dx(4))**2.d0 / 2.d0 + 3.d0*abs(l4 / dx(4))**3.d0 / 2.d0
            else
              w4 = 0.5d0 * (2.0d0 - abs(l4 / dx(4)))**2.d0 * (1.d0 - abs(l4 / dx(4)))
            endif
            ;
            if (abs(l5 / dx(5)) .lt. 1.d0) then 
              w5 = 1.d0 - 5.d0*abs(l5 / dx(5))**2.d0 / 2.d0 + 3.d0*abs(l5 / dx(5))**3.d0 / 2.d0
            else
              w5 = 0.5d0 * (2.0d0 - abs(l5 / dx(5)))**2.d0 * (1.d0 - abs(l5 / dx(5)))
            endif                        
            ]

            weight = CHF_DTERM[w0; *w1; *w2; *w3; *w4; *w5]

            rho(CHF_IX[ii; jj; kk; ll; mm; nn]) = 
     &            rho(CHF_IX[ii; jj; kk; ll; mm; nn]) + particle_rho * weight

           CHF_DTERM[
                   enddo;
                 enddo;
               enddo;
             enddo;
           enddo;
         enddo]

      end

c     Interpolates the field to the particle position using the 3rd order 
c     interpolation function from Wang, Miller, and Colella 2010
c
c     Arguments:
c
c         particle_field: the field interpolated to the particle position
c         field:          the field data stored on the mesh
c         left_edge:      the physical location of the left edge of the domain
c         dx:             the mesh spacing
c         x:              the position coordinate of the particle
c
      subroutine w4_interpolate(
     &                          CHF_REALVECT[particle_field],
     &                          CHF_CONST_FRA[field],
     &                          CHF_CONST_REALVECT[left_edge],
     &                          CHF_CONST_REALVECT[dx],
     &                          CHF_CONST_REALVECT[x])

      integer index(0:CH_SPACEDIM - 1)
      integer idir
      REAL_T volume, CHF_DDECL[l0;l1;l2;l3;l4;l5]
      REAL_T weight, CHF_DDECL[w0;w1;w2;w3;w4;w5]
      integer CHF_DDECL[ii;jj;kk;ll;mm;nn]

c     compute the index of the cell that contains the LEFT edge of
c     this particle cloud.
      do idir = 0, CH_SPACEDIM - 1
        index(idir) = floor((x(idir) - left_edge(idir) - 1.5d0*dx(idir)) / dx(idir))
      enddo

c     loop over all the cells containing this particle cloud,
c     computing weight and assigning mass
      CHF_DTERM[
      do ii = index(0), index(0) + 3
        l0 = ii*dx(0) + 0.5d0*dx(0) - x(0) + left_edge(0);
        do jj = index(1), index(1) + 3
          l1 = jj*dx(1) + 0.5d0*dx(1) - x(1) + left_edge(1);
          do kk = index(2), index(2) + 3
            l2 = kk*dx(2) + 0.5d0*dx(2) - x(2) + left_edge(2);
            do ll = index(3), index(3) + 3
              l3 = ll*dx(3) + 0.5d0*dx(3) - x(3) + left_edge(3);
              do mm = index(4), index(4) + 3
                l4 = mm*dx(4) + 0.5d0*dx(4) - x(4) + left_edge(4);
                do nn = index(5), index(5) + 3
                  l5 = nn*dx(5) + 0.5d0*dx(5) - x(5) + left_edge(5)]

            CHF_DTERM[
            if (abs(l0 / dx(0)) .lt. 1.d0) then 
              w0 = 1.d0 - 5.d0*abs(l0 / dx(0))**2.d0 / 2.d0 + 3.d0*abs(l0 / dx(0))**3.d0 / 2.d0
            else
              w0 = 0.5d0 * (2.0d0 - abs(l0 / dx(0)))**2.d0 * (1.d0 - abs(l0 / dx(0)))
            endif
            ;
            if (abs(l1 / dx(1)) .lt. 1.d0) then 
              w1 = 1.d0 - 5.d0*abs(l1 / dx(1))**2.d0 / 2.d0 + 3.d0*abs(l1 / dx(1))**3.d0 / 2.d0
            else
              w1 = 0.5d0 * (2.0d0 - abs(l1 / dx(1)))**2.d0 * (1.d0 - abs(l1 / dx(1))) 
            endif
            ;
            if (abs(l2 / dx(2)) .lt. 1.d0) then 
              w2 = 1.d0 - 5.d0*abs(l2 / dx(2))**2.d0 / 2.d0 + 3.d0*abs(l2 / dx(2))**3.d0 / 2.d0
            else
              w2 = 0.5d0 * (2.0d0 - abs(l2 / dx(2)))**2.d0 * (1.d0 - abs(l2 / dx(2)))
            endif
            ;
            if (abs(l3 / dx(3)) .lt. 1.d0) then 
              w3 = 1.d0 - 5.d0*abs(l3 / dx(3))**2.d0 / 2.d0 + 3.d0*abs(l3 / dx(3))**3.d0 / 2.d0
            else
              w3 = 0.5d0 * (2.0d0 - abs(l3 / dx(3)))**2.d0 * (1.d0 - abs(l3 / dx(3)))
            endif
            ;
            if (abs(l4 / dx(4)) .lt. 1.d0) then 
              w4 = 1.d0 - 5.d0*abs(l4 / dx(4))**2.d0 / 2.d0 + 3.d0*abs(l4 / dx(4))**3.d0 / 2.d0
            else
              w4 = 0.5d0 * (2.0d0 - abs(l4 / dx(4)))**2.d0 * (1.d0 - abs(l4 / dx(4)))
            endif
            ;
            if (abs(l5 / dx(5)) .lt. 1.d0) then 
              w5 = 1.d0 - 5.d0*abs(l5 / dx(5))**2.d0 / 2.d0 + 3.d0*abs(l5 / dx(5))**3.d0 / 2.d0
            else
              w5 = 0.5d0 * (2.0d0 - abs(l5 / dx(5)))**2.d0 * (1.d0 - abs(l5 / dx(5)))
            endif                        
            ]

            weight = CHF_DTERM[w0; *w1; *w2; *w3; *w4; *w5]

            do idir = 0, CH_SPACEDIM - 1

              particle_field(idir) = particle_field(idir) + 
     &                 weight * field(CHF_IX[ii; jj; kk; ll; mm; nn], idir)

            enddo

      CHF_DTERM[
                enddo;
              enddo;
            enddo;
          enddo;
        enddo;
      enddo]

      end
