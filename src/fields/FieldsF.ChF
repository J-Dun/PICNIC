c  ----------------------------------------------------------------------------

      subroutine compute_Jx_from_mass_matrix(
     &     CHF_BOX[box],
     &     CHF_CONST_INTVECT[Ncxx],
     &     CHF_CONST_INTVECT[Ncxy],
     &     CHF_CONST_INTVECT[Ncxz],
     &     CHF_CONST_FRA[sigmaxx],
     &     CHF_CONST_FRA[sigmaxy],
     &     CHF_CONST_FRA[sigmaxz],
     &     CHF_CONST_FRA1[Ex0],
     &     CHF_CONST_FRA1[Ex],
     &     CHF_CONST_FRA1[Ey0],
     &     CHF_CONST_FRA1[Ey],
     &     CHF_CONST_FRA1[Ez0],
     &     CHF_CONST_FRA1[Ez],
     &     CHF_CONST_FRA1[Jx0],
     &     CHF_FRA1[Jx]
     & )

c     local variables
      integer CHF_DDECL[i;j;k], Nc, idir
      integer CHF_DDECL[ii;jj;kk], offset_xx(0:CH_SPACEDIM - 1)
      integer offset_xy(0:CH_SPACEDIM - 1), offset_xz(0:CH_SPACEDIM - 1)
      REAL_T dEx, dEy, dEz
      REAL_T sigxxdEx, sigxydEy, sigxzdEz, sigdE
      
c     compute offset in each dir (careful with staggering...)
      do idir = 0, CH_SPACEDIM - 1
        offset_xx(idir) = (Ncxx(idir)-1)/2
        offset_xy(idir) = (Ncxy(idir)-1)/2
        offset_xz(idir) = (Ncxz(idir)-1)/2
        if(idir==1) then
          offset_xy(idir) = Ncxy(idir)/2
        endif  
        if(idir==2) then
          offset_xz(idir) = Ncxz(idir)/2
        endif
      enddo

      CHF_MULTIDO[box;i;j;k]

        sigxxdEx = zero
        CHF_DTERM[
        do ii = 0, Ncxx(0)-1;
          do jj = 0, Ncxx(1)-1;
            do kk = 0, Ncxx(2)-1]

        dEx =  Ex(CHF_IX[i+ii-offset_xx(0);j+jj-offset_xx(1);k+kk-offset_xx(2)])
     &      - Ex0(CHF_IX[i+ii-offset_xx(0);j+jj-offset_xx(1);k+kk-offset_xx(2)])

        Nc = CHF_DTERM[ii; + Ncxx(0)*jj; + Ncxx(0)*Ncxx(1)*kk]
        sigxxdEx = sigxxdEx + sigmaxx(CHF_IX[i;j;k],Nc)*dEx

        CHF_DTERM[
            enddo;
          enddo;
        enddo]
        
        sigxydEy = zero
        CHF_DTERM[
        do ii = 0, Ncxy(0)-1;
          do jj = 0, Ncxy(1)-1;
            do kk = 0, Ncxy(2)-1]
        
        dEy =  Ey(CHF_IX[i+ii-offset_xy(0);j+jj-offset_xy(1);k+kk-offset_xy(2)])
     &      - Ey0(CHF_IX[i+ii-offset_xy(0);j+jj-offset_xy(1);k+kk-offset_xy(2)])

        Nc = CHF_DTERM[ii; + Ncxy(0)*jj; + Ncxy(0)*Ncxy(1)*kk]
        sigxydEy = sigxydEy + sigmaxy(CHF_IX[i;j;k],Nc)*dEy

        CHF_DTERM[
            enddo;
          enddo;
        enddo]

        sigxzdEz = zero
        CHF_DTERM[
        do ii = 0, Ncxz(0)-1;
          do jj = 0, Ncxz(1)-1;
            do kk = 0, Ncxz(2)-1]
        
        dEz =  Ez(CHF_IX[i+ii-offset_xz(0);j+jj-offset_xz(1);k+kk-offset_xz(2)])
     &      - Ez0(CHF_IX[i+ii-offset_xz(0);j+jj-offset_xz(1);k+kk-offset_xz(2)])

        Nc = CHF_DTERM[ii; + Ncxz(0)*jj; + Ncxz(0)*Ncxz(1)*kk]
        sigxzdEz = sigxzdEz + sigmaxz(CHF_IX[i;j;k],Nc)*dEz

        CHF_DTERM[
            enddo;
          enddo;
        enddo]

        sigdE = sigxxdEx + sigxydEy + sigxzdEz
        Jx(CHF_IX[i;j;k]) = Jx0(CHF_IX[i;j;k]) + sigdE

      CHF_ENDDO

      return
      end

c  ----------------------------------------------------------------------------

      subroutine compute_Jy_from_mass_matrix(
     &     CHF_BOX[box],
     &     CHF_CONST_INTVECT[Ncyx],
     &     CHF_CONST_INTVECT[Ncyy],
     &     CHF_CONST_INTVECT[Ncyz],
     &     CHF_CONST_FRA[sigmayx],
     &     CHF_CONST_FRA[sigmayy],
     &     CHF_CONST_FRA[sigmayz],
     &     CHF_CONST_FRA1[Ex0],
     &     CHF_CONST_FRA1[Ex],
     &     CHF_CONST_FRA1[Ey0],
     &     CHF_CONST_FRA1[Ey],
     &     CHF_CONST_FRA1[Ez0],
     &     CHF_CONST_FRA1[Ez],
     &     CHF_CONST_FRA1[Jy0],
     &     CHF_FRA1[Jy]
     & )

c     local variables
      integer CHF_DDECL[i;j;k], Nc, idir
      integer CHF_DDECL[ii;jj;kk], offset_yx(0:CH_SPACEDIM - 1)
      integer offset_yy(0:CH_SPACEDIM - 1), offset_yz(0:CH_SPACEDIM - 1)
      REAL_T dEx, dEy, dEz
      REAL_T sigyxdEx, sigyydEy, sigyzdEz, sigdE

c     compute offset in each dir (careful with staggering...)
      do idir = 0, CH_SPACEDIM - 1
        offset_yx(idir) = (Ncyx(idir)-1)/2
        offset_yy(idir) = (Ncyy(idir)-1)/2
        offset_yz(idir) = (Ncyz(idir)-1)/2
        if(idir==0) then
          offset_yx(idir) = Ncyx(idir)/2
        endif  
        if(idir==2) then
          offset_yz(idir) = Ncyz(idir)/2
        endif
      enddo

      CHF_MULTIDO[box;i;j;k]

        sigyxdEx = zero
        CHF_DTERM[
        do ii = 0, Ncyx(0)-1;
          do jj = 0, Ncyx(1)-1;
            do kk = 0, Ncyx(2)-1]

        dEx =  Ex(CHF_IX[i+ii-offset_yx(0);j+jj-offset_yx(1);k+kk-offset_yx(2)])
     &      - Ex0(CHF_IX[i+ii-offset_yx(0);j+jj-offset_yx(1);k+kk-offset_yx(2)])

        Nc = CHF_DTERM[ii; + Ncyx(0)*jj; + Ncyx(0)*Ncyx(1)*kk]
        sigyxdEx = sigyxdEx + sigmayx(CHF_IX[i;j;k],Nc)*dEx

        CHF_DTERM[
            enddo;
          enddo;
        enddo]

        sigyydEy = zero
        CHF_DTERM[
        do ii = 0, Ncyy(0)-1;
          do jj = 0, Ncyy(1)-1;
            do kk = 0, Ncyy(2)-1]

        dEy =  Ey(CHF_IX[i+ii-offset_yy(0);j+jj-offset_yy(1);k+kk-offset_yy(2)])
     &      - Ey0(CHF_IX[i+ii-offset_yy(0);j+jj-offset_yy(1);k+kk-offset_yy(2)])

        Nc = CHF_DTERM[ii; + Ncyy(0)*jj; + Ncyy(0)*Ncyy(1)*kk]
        sigyydEy = sigyydEy + sigmayy(CHF_IX[i;j;k],Nc)*dEy 

        CHF_DTERM[
            enddo;
          enddo;
        enddo]

        sigyzdEz = zero
        CHF_DTERM[
        do ii = 0, Ncyz(0)-1;
          do jj = 0, Ncyz(1)-1;
            do kk = 0, Ncyz(2)-1]

        dEz =  Ez(CHF_IX[i+ii-offset_yz(0);j+jj-offset_yz(1);k+kk-offset_yz(2)])
     &      - Ez0(CHF_IX[i+ii-offset_yz(0);j+jj-offset_yz(1);k+kk-offset_yz(2)])

        Nc = CHF_DTERM[ii; + Ncyz(0)*jj; + Ncyz(0)*Ncyz(1)*kk]
        sigyzdEz = sigyzdEz + sigmayz(CHF_IX[i;j;k],Nc)*dEz 

        CHF_DTERM[
            enddo;
          enddo;
        enddo]

        sigdE = sigyxdEx + sigyydEy + sigyzdEz
        Jy(CHF_IX[i;j;k]) = Jy0(CHF_IX[i;j;k]) + sigdE

      CHF_ENDDO

      return
      end

c  ----------------------------------------------------------------------------

      subroutine compute_Jz_from_mass_matrix(
     &     CHF_BOX[box],
     &     CHF_CONST_INTVECT[Nczx],
     &     CHF_CONST_INTVECT[Nczy],
     &     CHF_CONST_INTVECT[Nczz],
     &     CHF_CONST_FRA[sigmazx],
     &     CHF_CONST_FRA[sigmazy],
     &     CHF_CONST_FRA[sigmazz],
     &     CHF_CONST_FRA1[Ex0],
     &     CHF_CONST_FRA1[Ex],
     &     CHF_CONST_FRA1[Ey0],
     &     CHF_CONST_FRA1[Ey],
     &     CHF_CONST_FRA1[Ez0],
     &     CHF_CONST_FRA1[Ez],
     &     CHF_CONST_FRA1[Jz0],
     &     CHF_FRA1[Jz]
     & )

c     local variables
      integer CHF_DDECL[i;j;k], Nc, idir
      integer CHF_DDECL[ii;jj;kk], offset_zx(0:CH_SPACEDIM - 1)
      integer offset_zy(0:CH_SPACEDIM - 1), offset_zz(0:CH_SPACEDIM - 1)
      REAL_T dEx, dEy, dEz
      REAL_T sigzxdEx, sigzydEy, sigzzdEz, sigdE
      
c     compute offset in each dir (careful with staggering...)
      do idir = 0, CH_SPACEDIM - 1
        offset_zx(idir) = (Nczx(idir)-1)/2
        offset_zy(idir) = (Nczy(idir)-1)/2
        offset_zz(idir) = (Nczz(idir)-1)/2
        if(idir==0) then
          offset_zx(idir) = Nczx(idir)/2
        endif  
        if(idir==1) then
          offset_zy(idir) = Nczy(idir)/2
        endif
      enddo

      CHF_MULTIDO[box;i;j;k]

        sigzxdEx = zero
        CHF_DTERM[
        do ii = 0, Nczx(0)-1;
          do jj = 0, Nczx(1)-1;
            do kk = 0, Nczx(2)-1]

        dEx =  Ex(CHF_IX[i+ii-offset_zx(0);j+jj-offset_zx(1);k+kk-offset_zx(2)])
     &      - Ex0(CHF_IX[i+ii-offset_zx(0);j+jj-offset_zx(1);k+kk-offset_zx(2)])

        Nc = CHF_DTERM[ii; + Nczx(0)*jj; + Nczx(0)*Nczx(1)*kk]
        sigzxdEx = sigzxdEx + sigmazx(CHF_IX[i;j;k],Nc)*dEx 

        CHF_DTERM[
            enddo;
          enddo;
        enddo]
        
        sigzydEy = zero
        CHF_DTERM[
        do ii = 0, Nczy(0)-1;
          do jj = 0, Nczy(1)-1;
            do kk = 0, Nczy(2)-1]

        dEy =  Ey(CHF_IX[i+ii-offset_zy(0);j+jj-offset_zy(1);k+kk-offset_zy(2)])
     &      - Ey0(CHF_IX[i+ii-offset_zy(0);j+jj-offset_zy(1);k+kk-offset_zy(2)])

        Nc = CHF_DTERM[ii; + Nczy(0)*jj; + Nczy(0)*Nczy(1)*kk]
        sigzydEy = sigzydEy + sigmazy(CHF_IX[i;j;k],Nc)*dEy 

        CHF_DTERM[
            enddo;
          enddo;
        enddo]

        sigzzdEz = zero
        CHF_DTERM[
        do ii = 0, Nczz(0)-1;
          do jj = 0, Nczz(1)-1;
            do kk = 0, Nczz(2)-1]

        dEz =  Ez(CHF_IX[i+ii-offset_zz(0);j+jj-offset_zz(1);k+kk-offset_zz(2)])
     &      - Ez0(CHF_IX[i+ii-offset_zz(0);j+jj-offset_zz(1);k+kk-offset_zz(2)])

        Nc = CHF_DTERM[ii; + Nczz(0)*jj; + Nczz(0)*Nczz(1)*kk]
        sigzzdEz = sigzzdEz + sigmazz(CHF_IX[i;j;k],Nc)*dEz 

        CHF_DTERM[
            enddo;
          enddo;
        enddo]

        sigdE = sigzxdEx + sigzydEy + sigzzdEz
        Jz(CHF_IX[i;j;k]) = Jz0(CHF_IX[i;j;k]) + sigdE

      CHF_ENDDO

      return
      end

c  ----------------------------------------------------------------------------

      subroutine compute_Jx_bdry_from_mass_matrix(
     &     CHF_BOX[box],
     &     CHF_CONST_INT[side],
     &     CHF_CONST_FRA[sigmaxx],
     &     CHF_CONST_FRA[sigmaxy],
     &     CHF_CONST_FRA[sigmaxz],
     &     CHF_CONST_FRA1[Ex0],
     &     CHF_CONST_FRA1[Ex],
     &     CHF_CONST_FRA1[Ey0],
     &     CHF_CONST_FRA1[Ey],
     &     CHF_CONST_FRA1[Ez0],
     &     CHF_CONST_FRA1[Ez],
     &     CHF_CONST_FRA1[Jx0],
     &     CHF_FRA1[Jx]
     & )

c     local variables
      integer CHF_DDECL[i;j;k], Ngx, nn, nn_min, nn_max, xx_base, xy_base
      REAL_T sigxxdEx, sigxydEy, sigxzdEz, sigdE

      Ngx = iboxhi0 - iboxlo0 + 1
      xx_base = (nsigmaxxcomp - 1)/2
      xy_base = nsigmaxycomp/2 - 1

      CHF_MULTIDO[box;i;j;k]
        
        sigxxdEx = zero
        sigxydEy = zero
        sigxzdEz = zero
        
        if(side.eq.zero) then
          nn_min = MAX(0,xx_base-Ngx-i)
          nn_max = nsigmaxxcomp-1
        else
          nn_min = 0
          nn_max = MIN(nsigmaxxcomp-1,xx_base+iboxhi0-i)
        endif

c        nn_min = -i*(1-side)
c        nn_max = nsigmaxxcomp-1 - (i-iboxlo0+1)*side
        do nn = nn_min, nn_max
          sigxxdEx = sigxxdEx + sigmaxx(CHF_IX[i;j;k],nn)*( Ex(CHF_IX[i+nn-xx_base;j;k])
     &                                                   - Ex0(CHF_IX[i+nn-xx_base;j;k]))
        enddo
        
        if(side.eq.zero) then
          nn_min = MAX(0,xy_base-Ngx-i)
          nn_max = nsigmaxycomp-1
        else
          nn_min = 0
          nn_max = MIN(nsigmaxycomp-1,xy_base+iboxhi0-i)
        endif

c        nn_min = -(i+1)*(1-side)
c        nn_max = nsigmaxycomp-1 - (i-iboxlo0)*side
        do nn = nn_min, nn_max
          sigxydEy = sigxydEy + sigmaxy(CHF_IX[i;j;k],nn)*( Ey(CHF_IX[i+nn-xy_base;j;k])
     &                                                   - Ey0(CHF_IX[i+nn-xy_base;j;k]))
          sigxzdEz = sigxzdEz + sigmaxz(CHF_IX[i;j;k],nn)*( Ez(CHF_IX[i+nn-xy_base;j;k])
     &                                                   - Ez0(CHF_IX[i+nn-xy_base;j;k]))
        enddo
        
        sigdE = sigxxdEx + sigxydEy + sigxzdEz

        Jx(CHF_IX[i;j;k]) = Jx0(CHF_IX[i;j;k]) + sigdE

      CHF_ENDDO

      return
      end

c  ----------------------------------------------------------------------------

      subroutine compute_Jy_bdry_from_mass_matrix(
     &     CHF_BOX[box],
     &     CHF_CONST_INT[side],
     &     CHF_CONST_FRA[sigmayx],
     &     CHF_CONST_FRA[sigmayy],
     &     CHF_CONST_FRA[sigmayz],
     &     CHF_CONST_FRA1[Ex0],
     &     CHF_CONST_FRA1[Ex],
     &     CHF_CONST_FRA1[Ey0],
     &     CHF_CONST_FRA1[Ey],
     &     CHF_CONST_FRA1[Ez0],
     &     CHF_CONST_FRA1[Ez],
     &     CHF_CONST_FRA1[Jy0],
     &     CHF_FRA1[Jy]
     & )

c     local variables
      integer CHF_DDECL[i;j;k], Ngx, nn, nn_min, nn_max, yx_base, yy_base
      REAL_T sigyxdEx, sigyydEy, sigyzdEz, sigdE

      Ngx = iboxhi0 - iboxlo0 + 1
      yx_base = nsigmayxcomp/2
      yy_base = (nsigmayycomp - 1)/2

      CHF_MULTIDO[box;i;j;k]
        
        sigyxdEx = zero
        sigyydEy = zero
        sigyzdEz = zero

        if(side.eq.zero) then
          nn_min = MAX(0,yx_base-Ngx-i)
          nn_max = nsigmayxcomp-1
        else
          nn_min = 0
          nn_max = MIN(nsigmayxcomp-1,yx_base+iboxhi0-i)
        endif

        do nn = nn_min, nn_max
          sigyxdEx = sigyxdEx + sigmayx(CHF_IX[i;j;k],nn)*( Ex(CHF_IX[i+nn-yx_base;j;k])
     &                                                   - Ex0(CHF_IX[i+nn-yx_base;j;k]))
        enddo
        
        if(side.eq.zero) then
          nn_min = MAX(0,yy_base-Ngx-i)
          nn_max = nsigmayycomp-1
        else
          nn_min = 0
          nn_max = MIN(nsigmayycomp-1,yy_base+iboxhi0-i)
        endif

        do nn = nn_min, nn_max
          sigyydEy = sigyydEy + sigmayy(CHF_IX[i;j;k],nn)*( Ey(CHF_IX[i+nn-yy_base;j;k])
     &                                                   - Ey0(CHF_IX[i+nn-yy_base;j;k]))
          sigyzdEz = sigyzdEz + sigmayz(CHF_IX[i;j;k],nn)*( Ez(CHF_IX[i+nn-yy_base;j;k])
     &                                                   - Ez0(CHF_IX[i+nn-yy_base;j;k]))
        enddo
        
        sigdE = sigyxdEx + sigyydEy + sigyzdEz

        Jy(CHF_IX[i;j;k]) = Jy0(CHF_IX[i;j;k]) + sigdE

      CHF_ENDDO

      return
      end

c  ----------------------------------------------------------------------------

      subroutine compute_Jz_bdry_from_mass_matrix(
     &     CHF_BOX[box],
     &     CHF_CONST_INT[side],
     &     CHF_CONST_FRA[sigmazx],
     &     CHF_CONST_FRA[sigmazy],
     &     CHF_CONST_FRA[sigmazz],
     &     CHF_CONST_FRA1[Ex0],
     &     CHF_CONST_FRA1[Ex],
     &     CHF_CONST_FRA1[Ey0],
     &     CHF_CONST_FRA1[Ey],
     &     CHF_CONST_FRA1[Ez0],
     &     CHF_CONST_FRA1[Ez],
     &     CHF_CONST_FRA1[Jz0],
     &     CHF_FRA1[Jz]
     & )

c     local variables
      integer CHF_DDECL[i;j;k], Ngx, nn, nn_min, nn_max, zx_base, zz_base
      REAL_T sigzxdEx, sigzydEy, sigzzdEz, sigdE

      Ngx = iboxhi0 - iboxlo0 + 1
      zx_base = nsigmazxcomp/2
      zz_base = (nsigmazzcomp - 1)/2

      CHF_MULTIDO[box;i;j;k]
        
        sigzxdEx = zero
        sigzydEy = zero
        sigzzdEz = zero

        if(side.eq.zero) then
          nn_min = MAX(0,zx_base-Ngx-i)
          nn_max = nsigmazxcomp-1
        else
          nn_min = 0
          nn_max = MIN(nsigmazxcomp-1,zx_base+iboxhi0-i)
        endif

        do nn = nn_min, nn_max
          sigzxdEx = sigzxdEx + sigmazx(CHF_IX[i;j;k],nn)*( Ex(CHF_IX[i+nn-zx_base;j;k])
     &                                                   - Ex0(CHF_IX[i+nn-zx_base;j;k]))
        enddo
        
        if(side.eq.zero) then
          nn_min = MAX(0,zz_base-Ngx-i)
          nn_max = nsigmazzcomp-1
        else
          nn_min = 0
          nn_max = MIN(nsigmazzcomp-1,zz_base+iboxhi0-i)
        endif

        do nn = nn_min, nn_max
          sigzydEy = sigzydEy + sigmazy(CHF_IX[i;j;k],nn)*( Ey(CHF_IX[i+nn-zz_base;j;k])
     &                                                   - Ey0(CHF_IX[i+nn-zz_base;j;k]))
          sigzzdEz = sigzzdEz + sigmazz(CHF_IX[i;j;k],nn)*( Ez(CHF_IX[i+nn-zz_base;j;k])
     &                                                   - Ez0(CHF_IX[i+nn-zz_base;j;k]))
        enddo
        
        sigdE = sigzxdEx + sigzydEy + sigzzdEz

        Jz(CHF_IX[i;j;k]) = Jz0(CHF_IX[i;j;k]) + sigdE

      CHF_ENDDO

      return
      end

c  ----------------------------------------------------------------------------

