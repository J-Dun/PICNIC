c  ----------------------------------------------------------------------------

      subroutine boris_pusher(
     &     CHF_REAL[vp0],
     &     CHF_REAL[vp1],
     &     CHF_REAL[vp2],
     &     CHF_CONST_REAL[vpold0],
     &     CHF_CONST_REAL[vpold1],
     &     CHF_CONST_REAL[vpold2],
     &     CHF_CONST_REAL[Ep0],
     &     CHF_CONST_REAL[Ep1],
     &     CHF_CONST_REAL[Ep2],
     &     CHF_CONST_REAL[Bp0],
     &     CHF_CONST_REAL[Bp1],
     &     CHF_CONST_REAL[Bp2],
     &     CHF_CONST_REAL[fnorm_const],
     &     CHF_CONST_REAL[cnormDt]
     & )

c     local variables
      REAL_T alpha, t0, t1, t2, denom, s0, s1, s2
      REAL_T vm0, vm1, vm2, vpr0, vpr1, vpr2
      Real_T vpl0, vpl1, vpl2

      alpha = fnorm_const*cnormDt/2.0

      t0 = alpha*Bp0
      t1 = alpha*Bp1
      t2 = alpha*Bp2
      denom = 1.0 + t0*t0 + t1*t1 + t2*t2
      s0 = 2.0*t0/denom
      s1 = 2.0*t1/denom
      s2 = 2.0*t2/denom

c     add half acceleration to old velocity
      vm0 = vpold0 + alpha*Ep0
      vm1 = vpold1 + alpha*Ep1
      vm2 = vpold2 + alpha*Ep2

c     define vpr = vm + vm x t
      vpr0 = vm0 + vm1*t2 - vm2*t1
      vpr1 = vm1 + vm2*t0 - vm0*t2
      vpr2 = vm2 + vm0*t1 - vm1*t0

c     rotate (define vplus = vminus + vprime x s)
      vpl0 = vm0 + vpr1*s2 - vpr2*s1
      vpl1 = vm1 + vpr2*s0 - vpr0*s2
      vpl2 = vm2 + vpr0*s1 - vpr1*s0

c     add another half acceleration
      vp0 = vpl0 + alpha*Ep0
      vp1 = vpl1 + alpha*Ep1
      vp2 = vpl2 + alpha*Ep2

      return
      end

c  ----------------------------------------------------------------------------


